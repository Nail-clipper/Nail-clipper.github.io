

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/congyu.jpg">
  <link rel="icon" href="/img/congyu.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Nail Clipper">
  <meta name="keywords" content="">
  
    <meta name="description" content="为了你的人身安全，不要在任何装有具有间谍性质的专有软件的设备上使用科学上网客户端。这些设备可以是手机，PC 等。在手机上,威权政府的监管机构可以轻易得到你所安装的应用列表，并可以通过各种手段关联并查询到你所做的事和发表的言论，并采取进一步控制，这是有先例的。理论上，在 PC 设备上也完全存在这种可能。如果你必须要使用微信，QQ 等具有间谍性质的专有软件，请在完全隔离的物理设备中使用。更多内容请阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="Arch Linux 魔法学院">
<meta property="og:url" content="https://wxwdaydayup.top/Arch%20Linux%20%E9%AD%94%E6%B3%95%E5%AD%A6%E9%99%A2/index.html">
<meta property="og:site_name" content="Ciallo～(∠・ω&lt; )⌒★">
<meta property="og:description" content="为了你的人身安全，不要在任何装有具有间谍性质的专有软件的设备上使用科学上网客户端。这些设备可以是手机，PC 等。在手机上,威权政府的监管机构可以轻易得到你所安装的应用列表，并可以通过各种手段关联并查询到你所做的事和发表的言论，并采取进一步控制，这是有先例的。理论上，在 PC 设备上也完全存在这种可能。如果你必须要使用微信，QQ 等具有间谍性质的专有软件，请在完全隔离的物理设备中使用。更多内容请阅读">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304135223269.png">
<meta property="og:image" content="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304135524174%20(1).png">
<meta property="og:image" content="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304150939449.png">
<meta property="og:image" content="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304155642843.png">
<meta property="og:image" content="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304155944933.png">
<meta property="article:published_time" content="2025-03-04T02:00:00.000Z">
<meta property="article:modified_time" content="2025-03-09T09:43:14.285Z">
<meta property="article:author" content="Nail Clipper">
<meta property="article:tag" content="Arch">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304135223269.png">
  
  
  
  <title>Arch Linux 魔法学院 - Ciallo～(∠・ω&lt; )⌒★</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wxwdaydayup.top","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Ciallo～(∠・ω< )⌒★" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ciallo～(∠・ω&lt; )⌒★</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Arch Linux 魔法学院"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-04 10:00" pubdate>
          2025年3月4日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          201 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Arch Linux 魔法学院</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2025-03-09T17:43:14+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p><strong>为了你的人身安全，不要在任何装有具有间谍性质的专有软件的设备上使用科学上网客户端。这些设备可以是手机，PC 等。在手机上,威权政府的监管机构可以轻易得到你所安装的应用列表，并可以通过各种手段关联并查询到你所做的事和发表的言论，并采取进一步控制，这是有先例的。理论上，在 PC 设备上也完全存在这种可能。如果你必须要使用微信，QQ 等具有间谍性质的专有软件，请在完全隔离的物理设备中使用。更多内容请阅读<a target="_blank" rel="noopener" href="https://archlinuxstudio.github.io/ModernSecurityProtectionGuide/#/">现代隐私保护指南</a>，这对你的安全非常重要！</strong></p>
<p>本节描述如何在 linux 下进行科学上网。如果没有配置好科学上网，那么你在日常使用中会遇到各种问题，不论是被封锁的资源或代码，还是查阅相关问题资料，你都会有可能无法下载和浏览。所有人<strong>必须</strong>配置好科学上网再继续。</p>
<h2 id="01-节点的准备"><a href="#01-节点的准备" class="headerlink" title="01. 节点的准备"></a>01. 节点的准备</h2><p>简单来讲节点是形如如下的神秘链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ss://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br>vmess://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br></code></pre></td></tr></table></figure>

<p>如果你没有这些连接，可以自行部署或者购买机场的订阅服务。</p>
<p>如果自行部署，你则需要自行购买处于自由互联网的服务器并进行节点搭建，这不在本文讨论范围内，仅提供三篇 GFW Report 的高质量文章作为参考。但是这些文章已被 GFW 屏蔽。我们之后会提供一些办法解决这个问题。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gfw.report/blog/ss_tutorial/zh/">如何部署一台抗封锁的 Shadowsocks-libev 服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://gfw.report/blog/ss_advise/zh/">防御 GFW 主动探测的实用指南</a></li>
<li><a target="_blank" rel="noopener" href="https://gfw.report/talks/imc20/zh/">Shadowsocks 是如何被检测和封锁的</a></li>
</ul>
<p>对于服务器的购买，我们提供一个网址以供参考: <a target="_blank" rel="noopener" href="https://bitcoin-vps.com/">https://bitcoin-vps.com/</a> 。bitcoin-vps 提供了非常详尽、且及时更新的服务器供应商列表，这些服务器供应商均在不同程度上支持使用加密货币进行支付，如比特币、以太坊等等。使用加密货币支付的好处在于，在正确操作的基础上，你可以完全保障自己的隐私安全。使用支付宝等实名支付手段购买类似的服务是不安全的，我们希望读者们可以认识到加密货币在各方面的价值，并认识到加密货币可以作为你的隐私保护者的存在。</p>
<p>如果购买机场的订阅服务，可以参考它们的订阅流程以获取节点。在我们列出一些较为可信的机场服务以供选择，但是我们不提供任何担保。需要提醒的是，机场服务属于灰色产业，随时有停止服务的可能，购买建议以月付进行购买以避免过大损失。关于机场审计规则，我们的观点是”我可以不看，但是你不可以封禁”。对于机场审计程度，读者可根据自身实际情况自行评估。</p>
<p>如果你不想花任何费用，可安装<a target="_blank" rel="noopener" href="https://psiphon3.com/zh/index.html">赛风</a>这类软件。赛风是自由软件。</p>
<p>如果你使用赛风，可以非常方便的发送空邮件到<a href="mailto:&#x67;&#x65;&#116;&#64;&#x70;&#115;&#x69;&#x70;&#x68;&#x6f;&#110;&#51;&#x2e;&#x63;&#111;&#x6d;">get@psiphon3.com</a>以获取赛风下载链接。赛风应用目前只支持 Windows\Android\IOS\MacOS 平台。当你在这些平台上能够访问自由互联网时，可以去各个渠道搜索可用的节点和代理资源，如<a target="_blank" rel="noopener" href="https://t.me/wtovpn">这个</a>或者<a target="_blank" rel="noopener" href="https://t.me/TG_Mtproxy_1">这个</a>。注意，使用公共节点需要自行承担可能的风险。</p>
<h2 id="02-安装"><a href="#02-安装" class="headerlink" title="02. 安装"></a>02. 安装</h2><p>V2rayA 是一款非常优秀的在 Linux 上可用的科学上网通用客户端。它是一款浏览器客户端，可以在服务器等 headless 环境中通过远程在浏览器端访问。</p>
<p>v2ray 是使用 V2rayA 的前提。需要先进行安装。在前面镜像源的选择一节中我们提到，读者应该尽快更换非威权国家的镜像源以保障自身的安全，<strong>在此处安装 v2ray 之前是你更换非威权国家的镜像源的最晚时刻</strong>。使用安全的镜像源安装 v2ray。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S v2ray<br></code></pre></td></tr></table></figure>

<p>V2rayA 是一个浏览器客户端，使用非常方便。由于作者提供了在墙内的下载地址，可以直接在 AUR 进行安装。安装后需启动服务。V2rayA 更新频繁，开发活跃，并且其安装和使用流程都对新手更加友好，推荐新人使用 V2rayA 进行科学上网。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yay -S v2raya-bin<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> --now v2raya<br></code></pre></td></tr></table></figure>

<p>随后在 KDE 菜单中搜索 v2raya，点击即可打开浏览器页面。登陆后在其中加入订阅即可使用。更多使用方法请看<a target="_blank" rel="noopener" href="https://v2raya.org/">官方文档</a>与<a target="_blank" rel="noopener" href="https://github.com/v2rayA/v2rayA">项目地址</a></p>
<blockquote>
<p>其他常见代理软件：</p>
<p>可参见<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8/%E4%BA%92%E8%81%94%E7%BD%91#%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">应用程序列表&#x2F;互联网#代理服务器</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Shadowsocks">Shadowsocks</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wzh/index.php?title=Trojan&action=edit&redlink=1">Trojan</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/WireGuard">WireGuard</a> 使用UDP的简单、快速、现代VPN，已内置于Linux内核（从5.7开始）</li>
<li>V2rayA：安装 <a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/v2raya/">v2raya</a></li>
<li>Clash-Verge: 安装<a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/clash-verge/">clash-verge</a></li>
<li>Dae：安装<a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/dae/">dae</a>或者<a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/daed/">daed</a>，其中 daed 是带有 WebUI 的 dae</li>
<li>v2rayN：安装<a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/v2rayn/">v2rayn</a>或者<a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/v2ran-bin/">v2ran-bin</a>（仅aur可用，需要正常连接 Github ）</li>
<li>Lantern（提示：蓝灯是专有软件）：安装 <a target="_blank" rel="noopener" href="https://aur.archlinux.org/packages/lantern-bin/">lantern-bin</a> 即可。</li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/XX-Net">XX-Net</a></li>
<li>更改 hosts： 获取可以科学上网的 hosts 文件，修改或替换 <code>/etc/hosts</code> 即可。</li>
</ul>
<p>示例：从 [<a target="_blank" rel="noopener" href="https://github.com/googlehosts/hosts">1]</a> 项目获取 <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/googlehosts/hosts/master/hosts-files/hosts">hosts</a> 文件，将其内容加入 <code>/etc/hosts</code>（如原 hosts 文件无需使用，也可直接覆盖）即可。也可执行更新 hosts 文件：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">&gt;sudo wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/googlehosts/</span>hosts<span class="hljs-regexp">/master/</span>hosts-files<span class="hljs-regexp">/hosts -O /</span>etc/hosts<br></code></pre></td></tr></table></figure>

<p>为方便起见，可将其使用 alias 别名方式写入 <code>.bashrc</code>，首先编辑 <code>~/.bashrc</code>，在其中添加：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&gt;<span class="hljs-keyword">alias</span> hosts=&#x27;sudo wget https:<span class="hljs-string">//raw.githubusercontent.com/googlehosts/hosts/master/hosts-files/hosts</span> -O <span class="hljs-string">/etc/hosts</span>&#x27;<br></code></pre></td></tr></table></figure>

<p>然后执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">source</span> ~/.bashrc</span><br></code></pre></td></tr></table></figure>

<p>以后更新 hosts 文件只需要执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">hosts</span><br></code></pre></td></tr></table></figure>

<p>即可。</p>
<p>**提示：**可以使用 <a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/Crontab">crontab</a> 定时执行脚本 (root 身份运行或 sudo 免密码)</p>
<p>**提示：**除 hosts 方法外，可能还需要进行相应的代理设置，如对程序单独设置代理或者使用工具设置临时代理（如使用 <a target="_blank" rel="noopener" href="https://archlinux.org/packages/?name=proxychains-ng">proxychains-ng</a>包 工具，配置好代理和 Proxychains 的配置文件后，使用<code>proxychains *程序名*</code> 使该程序从代理进行联网）或者全局代理（如桌面环境的设置中可能提供该选项），可参考各工具的相应文档进行设置，或者参考<a target="_blank" rel="noopener" href="https://wiki.archlinuxcn.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理设置</a>一文。</p>
</blockquote>
<h2 id="03-代理的初步设置"><a href="#03-代理的初步设置" class="headerlink" title="03. 代理的初步设置"></a>03. 代理的初步设置</h2><p>在经过上述步骤后，你应该已经有了 SOCKS5 代理以及 HTTP 代理的地址和端口。本小节描述如何单独为一些程序设置代理，但是需要提醒的是，这不是我们推荐的使用方式，如果你是 Linux 的日常重度使用者，你应该使用后续将会讲述的全局代理方式。</p>
<p>在节点链接后，你可在 KDE 的<code>系统设置</code> -&gt; <code>网络设置</code> -&gt; <code>代理</code>中设置代理。注意，<code>系统设置</code>中的代理配置在 KDE 桌面环境中并不是所有应用都会遵守，经过测试，chrome&#x2F;chromium&#x2F;brave 浏览器与 steam 等应用会遵循 KDE 的系统代理设置。没有遵循系统设置代理的应用还需要单独进行代理配置。下面说明几种常用的软件中单独配置代理的方式。</p>
<ul>
<li><p>Firefox 浏览器<br>火狐浏览器自身的设置选项中存在代理配置，进行配置即可。</p>
</li>
<li><p>终端<br>可以通过 export 命令设置当前终端的代理方式。比如使用 tldr 或 github raw 等资源需要设置 https 代理。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=http://127.0.0.1:8889<br><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:8889<br><span class="hljs-built_in">export</span> all_proxy=http://127.0.0.1:8889<br></code></pre></td></tr></table></figure>

<blockquote>
<p>不同终端命令所识别的环境变量名不同，如 all_proxy 对 curl 生效，而对 wget 则不生效，具体可查看各个命令的 man page。</p>
</blockquote>
<ul>
<li>code OSS<br>File &#x3D;&gt; Preference &#x3D;&gt; Settings<br>搜索 proxy，在其中填入 http 代理地址即可</li>
<li>proxychains-ng<br>如果对于一个应用，KDE 的全局代理不生效，在终端 export 了 ALL_PROXY 变量再用终端启动此应用代理也不生效，并且这个应用自身也没有配置代理的选项，此时可以尝试使用 proxychains-ng，它可以为单行命令配置代理。它是一个预加载的 hook，允许通过一个或多个 SOCKS 或 HTTP 代理重定向现有动态链接程序的 TCP 流量。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S proxychains-ng<br><span class="hljs-built_in">sudo</span> vim /etc/proxychains.conf<br></code></pre></td></tr></table></figure>

<p>把配置文件中最后一行改为本地代理的 ip 和端口，如<code>socks5 127.0.0.1 1089</code></p>
<p>proxychains 不能够支持 yay 以及其他一些程序，详见<a target="_blank" rel="noopener" href="https://github.com/Jguer/yay/issues/429">Incompatible with proxychains</a><a target="_blank" rel="noopener" href="https://github.com/rofl0r/proxychains-ng/issues/199">proxychains4 with Go lang</a>。这种情况可以使用透明代理。</p>
<h2 id="04-更加全面的系统级全局代理"><a href="#04-更加全面的系统级全局代理" class="headerlink" title="04. 更加全面的系统级全局代理"></a>04. 更加全面的系统级全局代理</h2><p>由以上各部分可以看到，为各个软件单独设置代理是很麻烦的。如果你把 Linux 作为主力使用，那么配置透明代理也是必须的，如果你使用 V2rayA,那么可以很方便的在设置中开启全局代理。如果你的技术水平不高，建议你直接使用 V2rayA 的全局代理。</p>
<p>全局代理，也即透明代理。本节所述为真正的，操作系统级别的代理，而不是仅仅针对浏览器中全部网址的”全局代理”。之所以叫做透明代理，是因为这种系统级别的代理对于操作系统中的各个应用相当于是透明的，应用们感知不到代理的存在。之所以叫做全局代理，很明显意为操作系统级别的、全局的代理。这两个词汇在中文环境中经常同时使用，并且全局代理一词容易引起混淆。</p>
<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304135223269.png" srcset="/img/loading.gif" lazyload></div><div class="group-image-wrap"><img src="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304135524174%20(1).png" srcset="/img/loading.gif" lazyload></div></div><div class="group-image-row"></div></div>

<h2 id="05-为什么我们不建议使用分流代理？分流代理可能存在什么危险？"><a href="#05-为什么我们不建议使用分流代理？分流代理可能存在什么危险？" class="headerlink" title="05. 为什么我们不建议使用分流代理？分流代理可能存在什么危险？"></a>05. 为什么我们不建议使用分流代理？分流代理可能存在什么危险？</h2><p>分流代理在大多数场景下指的是：在访问国内资源时，使用直连的方式，而在访问国外被墙的资源时，使用代理进行连接。这种网络的使用方式确实会非常方便，但是存在显而易见的危险，然而大众几乎并没有意识到这里的问题。</p>
<p>使用分流代理的方式非常容易泄露你自身的隐私信息，包括但不限于 IP 地址，浏览器以及硬件指纹(几乎可以唯一标记你这一个用户的指纹)等等一系列信息，并且可以将你使用的代理 IP 与你自身的真实 IP 进行对应。</p>
<p>举例来说，一个最常见的例子就是某个国外的网站使用了百度统计脚本，这时你的代理 IP 与真实 IP 的对应信息可以轻松的被这样的网站进行对应，这是非常危险的。 另一个例子就是一些恶意的邮件，比如你在使用国外的邮箱服务，接收到了一个恶意邮件，这个邮件中嵌入了一些国内的资源如图片，那么你的真实 IP 等信息也可以被轻松获取。</p>
<p>真实的例子不止以上两个，还有很多类似的情况存在。我们一直为了大众的隐私与安全而战，希望今后你可以放弃使用分流代理的网络连接方式。</p>
<h2 id="06-如何制作一个-IP-代理池？"><a href="#06-如何制作一个-IP-代理池？" class="headerlink" title="06. 如何制作一个 IP 代理池？"></a>06. 如何制作一个 IP 代理池？</h2><p>我们在上文中了解了单独配置代理和使用透明代理的方法，但是上述方法都是基于购买代理提供商的服务来完成的，如果你想高效利用互联网上大量的公开的免费代理，那么就需要搭建一个高效易用的代理池了，请使用 Python 3.9 及以上的版本运行本节代码。</p>
<ol>
<li><p>这里代理池的存储需要借助于 Redis，因此需要额外安装它。总体来说，本节需要的环境如下：</p>
<ul>
<li><p>需要安装并成功运行和连接一个 Redis 数据库，Redis 运行在本地或者远端服务器都可以，只要能正常连接就行</p>
</li>
<li><p>安装好一些必要的库，包括 aiohttp、requests、redis-py、pyquery、Flask、loguru 等，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install aiohttp requests redis pyquery flask loguru<br></code></pre></td></tr></table></figure></li>
</ul>
<p>做好了如上准备工作，我们便可以开始实现或运行本节所讲的代理池了</p>
</li>
<li><p>代理池的目标</p>
<p>我们需要做到下面几个目标来实现易用高效的代理池。</p>
<p>代理池基本模块分为 4 部分：存储模块、获取模块、检测模块和接口模块，其功能如下：</p>
<ul>
<li><strong>存储模块</strong>：负责存储抓取下来的代理。首先要保证代理不重复，要标识代理的可用情况，还要动态实时处理每个代理，所以一种比较高效和方便的存储方式就是使用 Redis 的 Sorted Set，即有序集合。</li>
<li><strong>获取模块</strong>：需要定时在各大代理网站抓取代理。代理既可以是免费公开代理，也可以是付费代理，代理的形式都是 IP 加端口。此模块尽量从不同来源获取，尽量抓取高匿代理，抓取成功之后将可用代理保存到数据库中。</li>
<li><strong>检测模块</strong>：需要定时检测数据库中的代理。这里需要设置一个检测链接，最好是登陆哪个网站就检测哪个网站，这样更加有针对性。如果要做一个通用型的代理，可以设置百度等链接来检测。另外，我们需要标识每一个代理的状态，如设置分数标识，100 分代表可用，分数越少代表越不可用。检测一次，如果代理可用，我们可以将分数标识立即设置为 100 满分，也可以在原基础上加 1 分；如果代理不可用，可以将分数标识减 1 分，当分数减到一定阈值后，代理就直接从数据库移除。通过这样标识分数，我们就可以辨别代理的可用情况，选用的时候会更有针对性。</li>
<li><strong>接口模块</strong>：需要用 API 来提供对外服务的接口。其实我们可以直接连接数据库来取对应的数据，但是这样就需要知道数据库的连接信息，并且要配置连接，而比较安全和方便的方式就是提供一个 Web API 接口，我们通过访问接口即可拿到可用代理。另外，由于可用代理可能有多个，所以我们可以设置一个随机返回某个可用代理的接口，这样就能保证每个可用代理都可以取到，实现负载均衡。</li>
</ul>
<p>以上内容是设计代理的一些基本思路。接下来，我们设计整体的架构，然后用代码实现代理池。</p>
</li>
<li><p>代理池的架构</p>
<p>根据上文的描述，代理池的架构如图所示：</p>
<p><img src="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304150939449.png" srcset="/img/loading.gif" lazyload></p>
<p>图中所示的代理池分为 4 个模块：存储模块、获取模块、检测模块和接口模块：</p>
<ul>
<li>存储模块使用 Redis 的有序集合，用来做代理的去重和状态标识，同时它也是中心模块和基础模块，用于将其他模块串联起来。</li>
<li>获取模块定时从代理网站获取代理，将获取的代理传递给存储模块，并保存到数据库。</li>
<li>检测模块定时通过存储模块获取所有代理，并对代理进行检测，根据不同的检测结果对代理设置不同的标识。</li>
<li>接口模块通过 Web API 提供服务接口，接口通过连接数据库并通过 Web 形式返回可用的代理。</li>
</ul>
</li>
<li><p>代理池的实现</p>
<p>接下来，我们分别用代码来实现一下这 4 个模块。</p>
<p><strong>存储模块</strong></p>
<p>这里我们使用 Redis 的有序集合，集合中的每一个元素都是不重复的。对于代理池来说，集合中的元素就变成了一个个代理，也就是 IP 加端口的形式，如 <code>60.207.237.111:8888</code>。另外，有序集合的每一个元素都有一个分数字段，分数是可以重复的，既可以是浮点数类型，也可以是整数类型。该集合会根据每一个元素的分数对集合进行排序，数值小的排在前面，数值大的排在后面，这样就可以实现集合元素的排序了。</p>
<p>对于代理池来说，这个分数可以作为判断一个代理是否可用的标志：100 为最高分，代表最可用；0 为最低分，代表最不可用。如果要获取可用代理，可以从代理池中随机获取分数最高的代理。注意这里是随机，这样可以保证每个可用代理都会被调用到。</p>
<p>分数是我们判断代理稳定性的重要标准。设置分数的规则如下所示。</p>
<ul>
<li>分数 100 为可用，检测器会定时循环检测每个代理的可用情况。一旦检测到有可用的代理，就立即置为 100；如果检测到不可用，就将分数减 1，分数减至 0 后代理移除。</li>
<li>新获取的代理的分数为 10，如果测试可行，分数立即置为 100，不可行则将分数减 1，分数减至 0 后代理移除。</li>
</ul>
<p>这只是一种解决方案，当然可能还有更合理的方案。之所以设置此方案，有如下几个原因。</p>
<ul>
<li>在检测到代理可用时，分数立即置为 100，这样可以保证所有可用代理有更大的机会被获取到。你可能会问，为什么不将分数加 1 而是直接将其设为最高值 100 呢？设想一下，有的代理是从各大免费公开代理网站获取的，常常一个代理并没有那么稳定，平均 5 次请求可能有 2 次成功，3 次失败。如果按照这种方式来设置分数，那么这个代理几乎不可能达到一个高的分数，也就是说即便它有时是可用的，但是筛选的分数为最高，那这样的代理几乎不可能被取到。如果想追求代理稳定性，可以用上述方法，这种方法可确保分数最高的代理一定是最稳定可用的。所以，这里我们采取 “可用即设置 100” 的方法，确保只要可用的代理都可以被获取到。</li>
<li>在检测到代理不可用时，分数减 1 ，分数减至 0 后，代理移除。这样一个有效代理如果被移除，需要连续不断失败 100 次。也就是说，当一个可用代理尝试了 100 次都失败了，就一直减分直到移除，一旦成功，就重新置回 100。尝试机会越多，这个代理拯救回来的机会越多，这样就不容易将曾经的一个可用代理丢弃，因为代理不可用的原因很可能是网络繁忙或者其他人用此代理请求太过频繁，所以这里将分数设为 100 。</li>
<li>将新获取的代理的分数设置为 10 ，如果它不可用，分数就减 1，直到减到 0 就移除；如果代理可用，分数就置为 100。由于很多代理是从免费网站获取的，所以新获取的代理无效的比例非常高，可能可用的代理不足 10%。这里我们将分数设置为 10，检测的机会没有可用代理的 100 次那么多，这也可以适当减少开销。</li>
</ul>
<p>上述代理分数的设置思路不一定是最优思路，但据个人实测，它的实用性还是比较强的。</p>
<p>这里首先给出存储模块的实现代码，在代码中，我们定义了一个类来操作数据库的有序集合，定义了一些方法来实现分数的设置、代理的获取等。其核心实现代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入 Redis 客户端库</span><br><span class="hljs-keyword">import</span> redis<br><span class="hljs-comment"># 从 proxypool.exceptions 模块中导入 PoolEmptyException 异常类，用于判空</span><br><span class="hljs-keyword">from</span> proxypool.exceptions <span class="hljs-keyword">import</span> PoolEmptyException<br><span class="hljs-comment"># 从 proxypool.schemas.proxy 模块中导入 Proxy 类</span><br><span class="hljs-keyword">from</span> proxypool.schemas.proxy <span class="hljs-keyword">import</span> Proxy<br><span class="hljs-comment"># 从 setting 模块导入一系列常量</span><br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> REDIS_CONNECTION_STRING, REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, REDIS_DB, REDIS_KEY, PROXY_SCORE_MAX, PROXY_SCORE_MIN, PROXY_SCORE_INIT<br><span class="hljs-comment"># 从 random 模块中导入 choice 函数</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><span class="hljs-comment"># 从 typing 模块中导入 List 类型</span><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-comment"># 从 loguru 模块中导入 logger 对象</span><br><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<br><span class="hljs-comment"># 从 proxypool.utils.proxy 模块中导入 is_valid_proxy 和 convert_proxy_or_proxies 函数</span><br><span class="hljs-keyword">from</span> proxypool.utils.proxy <span class="hljs-keyword">import</span> is_valid_proxy, convert_proxy_or_proxies<br><br><span class="hljs-comment"># 将 Redis 客户端的版本号赋给 REDIS_CLIENT_VERSION 变量</span><br>REDIS_CLIENT_VERSION = redis.__version__<br><span class="hljs-comment"># 如果 Redis 客户端版本以 &#x27;2.&#x27; 开头，则将 IS_REDIS_VERSION_2 设置为 True，否则为 False</span><br>IS_REDIS_VERSION_2 = REDIS_CLIENT_VERSION.startswith(<span class="hljs-string">&#x27;2.&#x27;</span>)<br><br><br><span class="hljs-comment"># 定义了一个名为 RedisClient 的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisClient</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    redis connection client of proxypool</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 初始化方法，用于创建Redis连接客户端</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD, db=REDIS_DB,</span><br><span class="hljs-params">                 connection_string=REDIS_CONNECTION_STRING, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        init redis client</span><br><span class="hljs-string">        :param host: redis host</span><br><span class="hljs-string">        :param port: redis port</span><br><span class="hljs-string">        :param password: redis password</span><br><span class="hljs-string">        :param connection_string: redis connection_string</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># if set connection_string, just use it</span><br>        <span class="hljs-comment"># 如果提供了连接字符串，则使用 redis.StrictRedis.from_url() 方法根据连接字符串创建 Redis 客户端连接</span><br>        <span class="hljs-comment"># 参数 decode_responses=True 表示在获取数据时自动解码为字符串类型，**kwargs 表示其他可能的关键字参数</span><br>        <span class="hljs-keyword">if</span> connection_string:<br>            <span class="hljs-variable language_">self</span>.db = redis.StrictRedis.from_url(connection_string, decode_responses=<span class="hljs-literal">True</span>, **kwargs)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.db = redis.StrictRedis(<br>                host=host, port=port, password=password, db=db, decode_responses=<span class="hljs-literal">True</span>, **kwargs)<br><br>    <span class="hljs-comment"># 添加代理到 Redis 中，并设置初始分数</span><br>    <span class="hljs-comment"># 定义了一个名为 add 的方法，它接受代理 (proxy)、分数 (score) 和 Redis 键 (redis_key) 作为参数，并返回一个整数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, proxy: Proxy, score=PROXY_SCORE_INIT, redis_key=REDIS_KEY</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        add proxy and set it to init score</span><br><span class="hljs-string">        :param proxy: proxy, ip:port, like 8.8.8.8:88</span><br><span class="hljs-string">        :param score: int score</span><br><span class="hljs-string">        :return: result</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 检查代理是否有效。使用 is_valid_proxy 函数检查代理的格式是否正确，即 IP:端口 格式</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_valid_proxy(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;proxy.host&#125;</span>:<span class="hljs-subst">&#123;proxy.port&#125;</span>&#x27;</span>):<br>            <span class="hljs-comment"># 用于记录信息级别的日志，将消息以字符串形式传递给日志记录器</span><br>            logger.info(<span class="hljs-string">f&#x27;invalid proxy <span class="hljs-subst">&#123;proxy&#125;</span>, throw it&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 检查代理是否已经存在于 Redis 中</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.exists(proxy, redis_key):<br>            <span class="hljs-comment"># 如果 Redis 客户端版本为 2.x，向有序集合中添加代理及其分数</span><br>            <span class="hljs-keyword">if</span> IS_REDIS_VERSION_2:<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.db.zadd(redis_key, score, proxy.string())<br>            <span class="hljs-comment"># redis_key 为有序集合的键名，&#123;proxy.string(): score&#125; 表示以代理对象的字符串表示作为键，分数作为值的字典</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.db.zadd(redis_key, &#123;proxy.string(): score&#125;)<br><br>    <span class="hljs-comment"># 从 Redis 中随机获取一个代理</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">random</span>(<span class="hljs-params">self, redis_key=REDIS_KEY, proxy_score_min=PROXY_SCORE_MIN, proxy_score_max=PROXY_SCORE_MAX</span>) -&gt; Proxy:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        get random proxy</span><br><span class="hljs-string">        firstly try to get proxy with max score</span><br><span class="hljs-string">        if not exists, try to get proxy by rank</span><br><span class="hljs-string">        if not exists, raise error</span><br><span class="hljs-string">        :return: proxy, like 8.8.8.8:8</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># try to get proxy with max score</span><br>        <span class="hljs-comment"># 使用 zrangebyscore() 方法从有序集合中获取分数为 proxy_score_max 的代理列表</span><br>        <span class="hljs-comment"># redis_key 是有序集合的键名，proxy_score_max 是分数的最大值</span><br>        proxies = <span class="hljs-variable language_">self</span>.db.zrangebyscore(<br>            redis_key, proxy_score_max, proxy_score_max)<br>        <span class="hljs-comment"># 检查代理列表是否非空</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(proxies):<br>            <span class="hljs-comment"># 如果代理列表非空，则随机选择一个代理，并通过 convert_proxy_or_proxies() 函数将其转换为代理对象</span><br>            <span class="hljs-comment"># choice(proxies) 用于从列表中随机选择一个元素</span><br>            <span class="hljs-keyword">return</span> convert_proxy_or_proxies(choice(proxies))<br>        <span class="hljs-comment"># else get proxy by rank</span><br>        <span class="hljs-comment"># 使用 zrevrange() 方法从有序集合中按分数范围逆序获取代理列表</span><br>        proxies = <span class="hljs-variable language_">self</span>.db.zrevrange(<br>            redis_key, proxy_score_min, proxy_score_max)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(proxies):<br>            <span class="hljs-keyword">return</span> convert_proxy_or_proxies(choice(proxies))<br>        <span class="hljs-comment"># else raise error</span><br>        <span class="hljs-comment"># 抛出 PoolEmptyException 异常，表示代理池为空</span><br>        <span class="hljs-keyword">raise</span> PoolEmptyException<br><br>    <span class="hljs-comment"># 减少代理的分数，如果分数小于最小分数，则删除该代理</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decrease</span>(<span class="hljs-params">self, proxy: Proxy, redis_key=REDIS_KEY, proxy_score_min=PROXY_SCORE_MIN</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        decrease score of proxy, if small than PROXY_SCORE_MIN, delete it</span><br><span class="hljs-string">        :param proxy: proxy</span><br><span class="hljs-string">        :return: new score</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 如果 Redis 客户端版本为 2.x，则使用方法减少代理的分数</span><br>        <span class="hljs-comment"># redis_key 是有序集合的键名，proxy.string() 是代理对象的字符串表示，-1 表示将分数减去 1</span><br>        <span class="hljs-keyword">if</span> IS_REDIS_VERSION_2:<br>            <span class="hljs-variable language_">self</span>.db.zincrby(redis_key, proxy.string(), -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.db.zincrby(redis_key, -<span class="hljs-number">1</span>, proxy.string())<br>        <span class="hljs-comment"># 获取减少后代理的新分数</span><br>        <span class="hljs-comment"># 使用 zscore() 方法获取代理在有序集合中的分数</span><br>        score = <span class="hljs-variable language_">self</span>.db.zscore(redis_key, proxy.string())<br>        <span class="hljs-comment"># 记录日志信息，说明代理的分数减少了 1，以及当前的分数</span><br>        logger.info(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;proxy.string()&#125;</span> score decrease 1, current <span class="hljs-subst">&#123;score&#125;</span>&#x27;</span>)<br>        <span class="hljs-comment"># 检查代理的分数是否小于等于最小分数</span><br>        <span class="hljs-comment"># 如果代理的分数小于等于最小分数，则记录日志信息，说明代理将被移除</span><br>        <span class="hljs-keyword">if</span> score &lt;= proxy_score_min:<br>            logger.info(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;proxy.string()&#125;</span> current score <span class="hljs-subst">&#123;score&#125;</span>, remove&#x27;</span>)<br>            <span class="hljs-comment"># 使用 zrem() 方法从有序集合中删除代理</span><br>            <span class="hljs-variable language_">self</span>.db.zrem(redis_key, proxy.string())<br><br>    <span class="hljs-comment"># 判断代理是否存在</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exists</span>(<span class="hljs-params">self, proxy: Proxy, redis_key=REDIS_KEY</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        if proxy exists</span><br><span class="hljs-string">        :param proxy: proxy</span><br><span class="hljs-string">        :return: if exists, bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 zscore() 方法从有序集合中获取代理的分数</span><br>        <span class="hljs-comment"># 如果代理存在于有序集合中，则 zscore() 方法返回其分数；如果不存在，则返回 None</span><br>        <span class="hljs-comment"># 用于检查代理是否存在，如果代理存在，则表达式的值为 False，否则为 True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.db.zscore(redis_key, proxy.string()) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 将代理的分数设置为最大值</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">max</span>(<span class="hljs-params">self, proxy: Proxy, redis_key=REDIS_KEY, proxy_score_max=PROXY_SCORE_MAX</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        set proxy to max score</span><br><span class="hljs-string">        :param proxy: proxy</span><br><span class="hljs-string">        :return: new score</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 记录日志信息，说明代理的分数将被设置为最大值</span><br>        logger.info(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;proxy.string()&#125;</span> is valid, set to <span class="hljs-subst">&#123;proxy_score_max&#125;</span>&#x27;</span>)<br>        <span class="hljs-comment"># redis_key 是有序集合的键名，&#123;proxy.string(): proxy_score_max&#125; 表示以代理对象的字符串表示作为键，最大分数作为值的字典</span><br>        <span class="hljs-keyword">if</span> IS_REDIS_VERSION_2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.db.zadd(redis_key, proxy_score_max, proxy.string())<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.db.zadd(redis_key, &#123;proxy.string(): proxy_score_max&#125;)<br><br>    <span class="hljs-comment"># 获取代理数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">self, redis_key=REDIS_KEY</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        get count of proxies</span><br><span class="hljs-string">        :return: count, int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 zcard() 方法获取有序集合中元素的数量</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.db.zcard(redis_key)<br><br>    <span class="hljs-comment"># 获取所有代理</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">self, redis_key=REDIS_KEY, proxy_score_min=PROXY_SCORE_MIN, proxy_score_max=PROXY_SCORE_MAX</span>) -&gt; <span class="hljs-type">List</span>[Proxy]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        get all proxies</span><br><span class="hljs-string">        :return: list of proxies</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 zrangebyscore() 方法从有序集合中获取分数在指定范围内的代理列表</span><br>        <span class="hljs-comment"># 返回一个代理对象的字符串表示列表</span><br>        <span class="hljs-comment"># convert_proxy_or_proxies() 函数将代理对象的字符串表示列表转换为代理对象列表</span><br>        <span class="hljs-keyword">return</span> convert_proxy_or_proxies(<span class="hljs-variable language_">self</span>.db.zrangebyscore(redis_key, proxy_score_min, proxy_score_max))<br><br>    <span class="hljs-comment"># 批量获取代理</span><br>    <span class="hljs-comment"># 定义了一个名为 batch 的方法，它接受扫描游标 (cursor)、扫描数量 (count) 和 Redis 键 (redis_key) 作为参数</span><br>    <span class="hljs-comment"># 返回一个代理对象列表</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">batch</span>(<span class="hljs-params">self, cursor, count, redis_key=REDIS_KEY</span>) -&gt; <span class="hljs-type">List</span>[Proxy]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        get batch of proxies</span><br><span class="hljs-string">        :param cursor: scan cursor</span><br><span class="hljs-string">        :param count: scan count</span><br><span class="hljs-string">        :return: list of proxies</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 zscan() 方法扫描有序集合，并返回一个扫描游标和一个元组列表，其中每个元组包含代理和分数</span><br>        <span class="hljs-comment"># cursor 是扫描游标，proxies 是一个元组列表，每个元组的第一个元素是代理的字符串表示</span><br>        cursor, proxies = <span class="hljs-variable language_">self</span>.db.zscan(redis_key, cursor, count=count)<br>        <span class="hljs-comment"># convert_proxy_or_proxies() 函数将代理对象的字符串表示列表转换为代理对象列表</span><br>        <span class="hljs-keyword">return</span> cursor, convert_proxy_or_proxies([i[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> proxies])<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个 RedisClient 实例</span><br>    conn = RedisClient()<br>    <span class="hljs-comment"># 从 Redis 中随机获取一个代理</span><br>    result = conn.random()<br>    <span class="hljs-comment"># 打印获取到的代理</span><br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure>
<p>相关模块：</p>
<p>proxypool.exceptions 模块: 用于判断代理池非空</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义了一个名为 PoolEmptyException 的异常类，它继承自 Python 内置的 Exception 类, 用于判空</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PoolEmptyException</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        proxypool is used out</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># repr() 生成的字符串通常是对象的标准表示形式，它在一定程度上可以唯一地标识一个对象，通常包括对象的类型和一些重要的状态信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">repr</span>(<span class="hljs-string">&#x27;no proxy in proxypool&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>proxypool.schemas.proxy 模块: 用于定义代理的格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从 attr 模块中导入 attrs 和 attr。</span><br><span class="hljs-comment"># attrs 是一个装饰器，用于声明类，attr 是一个函数，用于定义类的属性</span><br><span class="hljs-keyword">from</span> attr <span class="hljs-keyword">import</span> attrs, attr<br><br><br><span class="hljs-comment"># 这是一个装饰器，用于将下面的类声明变为具有特殊功能的类。在这里，它将类 Proxy 声明为一个具有属性定义功能的类</span><br><span class="hljs-meta">@attrs</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_ inherited__">object</span>):  <span class="hljs-comment"># 定义了一个名为 Proxy 的类，代表了代理的模式或结构</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    proxy schema</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    host = attr(<span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-literal">None</span>)<br>    port = attr(<span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-literal">None</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        to string, for print</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.host&#125;</span>:<span class="hljs-subst">&#123;self.port&#125;</span>&#x27;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">string</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        to string</span><br><span class="hljs-string">        :return: &lt;host&gt;:&lt;port&gt;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__str__()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    proxy = Proxy(host=<span class="hljs-string">&#x27;8.8.8.8&#x27;</span>, port=<span class="hljs-number">8888</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;proxy&#x27;</span>, proxy)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;proxy&#x27;</span>, proxy.string())<br></code></pre></td></tr></table></figure>
<p>setting 模块: 用于定义一些常量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入 Python 的 platform 模块，用于获取系统信息</span><br><span class="hljs-keyword">import</span> platform<br><span class="hljs-comment"># 从 Python 的 os.path 模块中导入 dirname、abspath 和 join 函数，用于处理文件路径</span><br><span class="hljs-keyword">from</span> os.path <span class="hljs-keyword">import</span> dirname, abspath, join<br><span class="hljs-comment"># 导入第三方库 environs，用于从环境变量中读取配置</span><br><span class="hljs-keyword">from</span> environs <span class="hljs-keyword">import</span> Env<br><span class="hljs-comment"># 导入第三方库 loguru，用于记录日志信息</span><br><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<br><span class="hljs-comment"># 导入 Python 的 shutil 模块，用于处理文件和目录</span><br><span class="hljs-keyword">import</span> shutil<br><br><br><span class="hljs-comment"># 创建 Env 对象，用于读取环境变量</span><br>env = Env()<br><span class="hljs-comment"># 从环境变量文件（通常是 .env 文件）中读取配置</span><br>env.read_env()<br><br><span class="hljs-comment"># 判断当前操作系统是否为 Windows</span><br>IS_WINDOWS = platform.system().lower() == <span class="hljs-string">&#x27;windows&#x27;</span><br><br><span class="hljs-comment"># 定义了一些常用的目录变量</span><br>ROOT_DIR = dirname(dirname(abspath(__file__)))<br>LOG_DIR = join(ROOT_DIR, env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;LOG_DIR&#x27;</span>, <span class="hljs-string">&#x27;logs&#x27;</span>))<br><br><span class="hljs-comment"># 根据环境变量的值来设置应用程序的模式和调试标志，以便在不同的环境下执行不同的逻辑</span><br><span class="hljs-comment"># 定义了三个字符串常量，分别表示开发环境、测试环境和生产环境</span><br>DEV_MODE, TEST_MODE, PROD_MODE = <span class="hljs-string">&#x27;dev&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;prod&#x27;</span><br><span class="hljs-comment"># 使用 env 对象的 str() 方法获取名为 APP_ENV 的环境变量的值，如果环境变量不存在，则默认值为 DEV_MODE</span><br>APP_ENV = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;APP_ENV&#x27;</span>, DEV_MODE).lower()<br><span class="hljs-comment"># 使用 env 对象的 bool() 方法获取名为 APP_DEBUG 的环境变量的值，如果环境变量不存在或APP_ENV 的值为 DEV_MODE，则默认值为 True</span><br>APP_DEBUG = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;APP_DEBUG&#x27;</span>, <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> APP_ENV == DEV_MODE <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 检查 APP_ENV 是否等于 DEV_MODE，如果是，则将 True 赋给 APP_DEV 和 IS_DEV 变量，否则将 False 赋给它们</span><br>APP_DEV = IS_DEV = APP_ENV == DEV_MODE<br>APP_PROD = IS_PROD = APP_ENV == PROD_MODE<br>APP_TEST = IS_TEST = APP_ENV == TEST_MODE<br><br><br><span class="hljs-comment"># 这段代码定义了用于运行应用程序的 WSGI</span><br><span class="hljs-comment"># WSGI容器是用于运行Python Web应用程序的服务器软件，例如Flask、Django等</span><br><span class="hljs-comment"># 根据环境变量的值选择WSGI容器，如果未设置，则默认使用gevent。在不同的部署环境下，可以根据需求选择不同的WSGI容器来运行应用程序</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"> Which WSGI container is used to run applications</span><br><span class="hljs-string">   - gevent: pip install gevent</span><br><span class="hljs-string">   - tornado: pip install tornado</span><br><span class="hljs-string">   - meinheld: pip install meinheld</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 定义了三个字符串常量，分别表示三种不同的WSGI容器选项</span><br>APP_PROD_METHOD_GEVENT = <span class="hljs-string">&#x27;gevent&#x27;</span><br>APP_PROD_METHOD_TORNADO = <span class="hljs-string">&#x27;tornado&#x27;</span><br>APP_PROD_METHOD_MEINHELD = <span class="hljs-string">&#x27;meinheld&#x27;</span><br><span class="hljs-comment"># 使用env对象的str()方法获取名为APP_PROD_METHOD的环境变量的值，如果环境变量不存在，则默认值为APP_PROD_METHOD_GEVENT</span><br>APP_PROD_METHOD = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;APP_PROD_METHOD&#x27;</span>, APP_PROD_METHOD_GEVENT).lower()<br><br><span class="hljs-comment"># 使用 env 对象的 str() 方法从环境变量中获取名为 PROXYPOOL_REDIS_HOST 的值，</span><br><span class="hljs-comment"># 如果不存在，则尝试获取名为 REDIS_HOST 的值作为备选,</span><br><span class="hljs-comment"># 如果两个环境变量都不存在，则将默认值设置为 &#x27;127.0.0.1&#x27;，表示 Redis 服务器的主机地址</span><br><span class="hljs-comment"># redis host</span><br>REDIS_HOST = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;PROXYPOOL_REDIS_HOST&#x27;</span>,<br>                     env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;REDIS_HOST&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>))<br><br><span class="hljs-comment"># 使用 env 对象的 int() 方法从环境变量中获取 Redis 端口号。如果环境变量不存在，则使用默认端口号 6379</span><br>REDIS_PORT = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;PROXYPOOL_REDIS_PORT&#x27;</span>, env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;REDIS_PORT&#x27;</span>, <span class="hljs-number">6379</span>))<br><br><span class="hljs-comment"># 获取 Redis 的密码。如果环境变量中没有设置密码，则将其设置为 None</span><br>REDIS_PASSWORD = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;PROXYPOOL_REDIS_PASSWORD&#x27;</span>,<br>                         env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;REDIS_PASSWORD&#x27;</span>, <span class="hljs-literal">None</span>))<br><span class="hljs-comment"># 获取 Redis 使用的数据库编号。如果未指定数据库编号，则默认使用 0</span><br>REDIS_DB = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;PROXYPOOL_REDIS_DB&#x27;</span>, env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;REDIS_DB&#x27;</span>, <span class="hljs-number">0</span>))<br><br><span class="hljs-comment"># please refer to https://redis-py.readthedocs.io/en/stable/connections.html#redis.client.Redis.from_url</span><br><span class="hljs-comment"># 获取 Redis 的连接字符串。连接字符串的格式通常为 redis://[password]@host:port 或 rediss://[password]@host:port/0。</span><br><span class="hljs-comment"># 该连接字符串可以指定 Redis 的主机地址、端口号、密码和数据库编号。</span><br><span class="hljs-comment"># 如果未提供连接字符串，则尝试从环境变量 PROXYPOOL_REDIS_CONNECTION_STRING 和 REDIS_CONNECTION_STRING 中获取，</span><br><span class="hljs-comment"># 如果都不存在，则设为 None</span><br><br>REDIS_CONNECTION_STRING = env.<span class="hljs-built_in">str</span>(<br>    <span class="hljs-string">&#x27;PROXYPOOL_REDIS_CONNECTION_STRING&#x27;</span>, env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;REDIS_CONNECTION_STRING&#x27;</span>, <span class="hljs-literal">None</span>))<br><br><span class="hljs-comment"># 获取 Redis 中存储代理的哈希表键名。如果环境变量中没有设置键名，则默认使用 &#x27;proxies:universal&#x27;</span><br>REDIS_KEY = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;PROXYPOOL_REDIS_KEY&#x27;</span>, env.<span class="hljs-built_in">str</span>(<br>    <span class="hljs-string">&#x27;REDIS_KEY&#x27;</span>, <span class="hljs-string">&#x27;proxies:universal&#x27;</span>))<br><br><span class="hljs-comment"># 用于定义代理池的评分和数量相关的配置信息</span><br><span class="hljs-comment"># 获取代理的最大分数。使用 env 对象的 int() 方法从环境变量中获取名为 PROXY_SCORE_MAX 的值，如果不存在，则默认为 100</span><br>PROXY_SCORE_MAX = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;PROXY_SCORE_MAX&#x27;</span>, <span class="hljs-number">100</span>)<br>PROXY_SCORE_MIN = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;PROXY_SCORE_MIN&#x27;</span>, <span class="hljs-number">0</span>)<br>PROXY_SCORE_INIT = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;PROXY_SCORE_INIT&#x27;</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># whether to get a universal random proxy if no proxy exists in the sub-pool identified by a specific key</span><br><span class="hljs-comment"># 设置是否在特定键标识的子池中不存在代理时，从通用池中获取随机代理。</span><br><span class="hljs-comment"># 使用 env 对象的 bool() 方法从环境变量中获取名为 TEST_ANONYMOUS 的值，如果不存在，则默认为 True</span><br>PROXY_RAND_KEY_DEGRADED = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;TEST_ANONYMOUS&#x27;</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 设置代理的最大数量为 50000, 最小数量为 0</span><br>PROXY_NUMBER_MAX = <span class="hljs-number">50000</span><br>PROXY_NUMBER_MIN = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 用于定义测试器的周期、测试URL、测试超时时间、测试批量数量等配置信息</span><br><span class="hljs-comment"># 定义测试器的周期，即每隔多少秒进行一次测试。使用 env 对象的 int() 方法从环境变量中获取名为 CYCLE_TESTER 的值，如果不存在，则默认为 20 秒</span><br>CYCLE_TESTER = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;CYCLE_TESTER&#x27;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-comment"># 定义获取器的周期，即每隔多少秒获取一次代理。使用 env 对象的 int() 方法从环境变量中获取名为 CYCLE_GETTER 的值，如果不存在，则默认为 100 秒</span><br>CYCLE_GETTER = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;CYCLE_GETTER&#x27;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment"># 定义获取代理的超时时间，即获取代理的最长等待时间。如果环境变量中不存在，则默认为 10 秒</span><br>GET_TIMEOUT = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;GET_TIMEOUT&#x27;</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 定义用于测试的URL地址。使用 env 对象的 str() 方法从环境变量中获取名为 TEST_URL 的值，如果不存在，则默认为 &#x27;http://www.baidu.com&#x27;</span><br>TEST_URL = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;TEST_URL&#x27;</span>, <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><span class="hljs-comment"># 定义测试的超时时间，即每个代理请求的最长等待时间。如果环境变量中不存在，则默认为 10 秒</span><br>TEST_TIMEOUT = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;TEST_TIMEOUT&#x27;</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># 定义每次测试的批量数量，即同时测试的代理数量。如果环境变量中不存在，则默认为 20</span><br>TEST_BATCH = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;TEST_BATCH&#x27;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-comment"># 定义是否仅保存匿名代理。使用 env 对象的 bool() 方法从环境变量中获取名为 TEST_ANONYMOUS 的值，如果不存在，则默认为 True</span><br>TEST_ANONYMOUS = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;TEST_ANONYMOUS&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># TEST_HEADERS = env.json(&#x27;TEST_HEADERS&#x27;, &#123;</span><br><span class="hljs-comment">#     &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&#x27;,</span><br><span class="hljs-comment"># &#125;)</span><br><span class="hljs-comment"># 定义有效的HTTP状态码列表。使用 env 对象的 list() 方法从环境变量中获取名为 TEST_VALID_STATUS 的值，如果不存在，则默认为 [200, 206, 302]</span><br>TEST_VALID_STATUS = env.<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;TEST_VALID_STATUS&#x27;</span>, [<span class="hljs-number">200</span>, <span class="hljs-number">206</span>, <span class="hljs-number">302</span>])<br><span class="hljs-comment"># 定义是否在一个代理被测试为有效时不设置最大分数。使用 env 对象的 bool() 方法从环境变量中获取名为 TEST_DONT_SET_MAX_SCORE 的值，</span><br><span class="hljs-comment"># 如果不存在，则默认为 False</span><br>TEST_DONT_SET_MAX_SCORE = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;TEST_DONT_SET_MAX_SCORE&#x27;</span>, <span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># 用于定义API相关的配置信息以及一些功能开关</span><br><span class="hljs-comment"># 定义API服务器的主机地址。使用 env 对象的 str() 方法从环境变量中获取名为 API_HOST 的值，如果不存在，则默认为 &#x27;0.0.0.0&#x27;，表示绑定到所有网络接口</span><br>API_HOST = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;API_HOST&#x27;</span>, <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>)<br><span class="hljs-comment"># 定义API服务器的端口号。使用 env 对象的 int() 方法从环境变量中获取名为 API_PORT 的值，如果不存在，则默认为 5555</span><br>API_PORT = env.<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;API_PORT&#x27;</span>, <span class="hljs-number">5555</span>)<br><span class="hljs-comment"># 定义API服务器是否使用多线程处理请求。使用 env 对象的 bool() 方法从环境变量中获取名为 API_THREADED 的值，如果不存在，则默认为 True</span><br>API_THREADED = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;API_THREADED&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义API的身份验证密钥。如果需要对API进行身份验证，则客户端需要在请求头中包含 API-KEY 的头部信息，并提供正确的密钥进行验证。</span><br><span class="hljs-comment"># 使用 env 对象的 str() 方法从环境变量中获取名为 API_KEY 的值，如果不存在，则默认为空字符串</span><br>API_KEY = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;API_KEY&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 定义是否启用代理测试器功能。使用 env 对象的 bool() 方法从环境变量中获取名为 ENABLE_TESTER 的值，如果不存在，则默认为 True</span><br>ENABLE_TESTER = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;ENABLE_TESTER&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义是否启用代理获取器功能</span><br>ENABLE_GETTER = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;ENABLE_GETTER&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义是否启用API服务器功能</span><br>ENABLE_SERVER = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;ENABLE_SERVER&#x27;</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 定义是否启用相应类型的日志记录功能。使用 env 对象的 bool() 方法从环境变量中获取相应的值，如果不存在，则默认为 True</span><br><span class="hljs-comment"># 定义是否启用普通日志文件记录功能</span><br>ENABLE_LOG_FILE = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;ENABLE_LOG_FILE&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义是否启用运行时日志文件记录功能</span><br>ENABLE_LOG_RUNTIME_FILE = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;ENABLE_LOG_RUNTIME_FILE&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 定义是否启用错误日志文件记录功能</span><br>ENABLE_LOG_ERROR_FILE = env.<span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;ENABLE_LOG_ERROR_FILE&#x27;</span>, <span class="hljs-literal">True</span>)<br><br><br><span class="hljs-comment"># 用于设置日志级别和日志文件的轮换和保留策略的配置信息</span><br><span class="hljs-comment"># 定义了一个字典，将不同的环境模式映射到对应的日志级别。</span><br><span class="hljs-comment"># 例如，DEV_MODE 对应 &quot;DEBUG&quot; 级别，TEST_MODE 对应 &quot;INFO&quot; 级别，PROD_MODE 对应 &quot;ERROR&quot; 级别</span><br>LOG_LEVEL_MAP = &#123;<br>    DEV_MODE: <span class="hljs-string">&quot;DEBUG&quot;</span>,<br>    TEST_MODE: <span class="hljs-string">&quot;INFO&quot;</span>,<br>    PROD_MODE: <span class="hljs-string">&quot;ERROR&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 根据当前的应用环境 APP_ENV，从 LOG_LEVEL_MAP 中获取相应的日志级别。如果 APP_ENV 对应的日志级别不存在于 LOG_LEVEL_MAP 中，则返回 None</span><br>LOG_LEVEL = LOG_LEVEL_MAP.get(APP_ENV)<br><span class="hljs-comment"># 定义日志文件的轮换策略，即当日志文件达到一定大小时如何进行轮换，默认为 &#x27;500MB&#x27;，表示当日志文件达到500MB时进行轮换</span><br>LOG_ROTATION = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;LOG_ROTATION&#x27;</span>, <span class="hljs-string">&#x27;500MB&#x27;</span>)<br><span class="hljs-comment"># 定义日志文件的保留策略，即保留多长时间的日志文件，默认为 &#x27;1 week&#x27;，表示保留一周的日志文件</span><br>LOG_RETENTION = env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;LOG_RETENTION&#x27;</span>, <span class="hljs-string">&#x27;1 week&#x27;</span>)<br><br><span class="hljs-comment"># 用于根据配置启用或禁用不同类型的日志记录，并根据配置的日志文件路径和设置的日志级别、轮换、保留策略添加相应的日志处理器，如果禁用日志记录，则删除日志目录</span><br><span class="hljs-keyword">if</span> ENABLE_LOG_FILE:  <span class="hljs-comment"># 检查是否启用了日志记录功能</span><br>    <span class="hljs-comment"># 如果启用了普通日志文件记录功能，则使用 logger.add() 方法添加一个记录器，记录器的文件路径由环境变量中的 LOG_RUNTIME_FILE 决定，</span><br>    <span class="hljs-comment"># 如果没有设置，则默认为 LOG_DIR 目录下的 runtime.log 文件。</span><br>    <span class="hljs-comment"># 日志的级别由 LOG_LEVEL 确定，轮换策略由 LOG_ROTATION 确定，保留策略由 LOG_RETENTION 确定</span><br>    <span class="hljs-keyword">if</span> ENABLE_LOG_RUNTIME_FILE:<br>        logger.add(env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;LOG_RUNTIME_FILE&#x27;</span>, join(LOG_DIR, <span class="hljs-string">&#x27;runtime.log&#x27;</span>)),<br>                   level=LOG_LEVEL, rotation=LOG_ROTATION, retention=LOG_RETENTION)<br>    <span class="hljs-comment"># 如果启用了错误日志文件记录功能，则使用 logger.add() 方法添加一个记录器，记录器的文件路径由环境变量中的 LOG_ERROR_FILE 决定，</span><br>    <span class="hljs-comment"># 如果没有设置，则默认为 LOG_DIR 目录下的 error.log 文件。日志的级别被设为 &#x27;ERROR&#x27;，表示只记录错误级别的日志</span><br>    <span class="hljs-keyword">if</span> ENABLE_LOG_ERROR_FILE:<br>        logger.add(env.<span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;LOG_ERROR_FILE&#x27;</span>, join(LOG_DIR, <span class="hljs-string">&#x27;error.log&#x27;</span>)),<br>                   level=<span class="hljs-string">&#x27;ERROR&#x27;</span>, rotation=LOG_ROTATION)<br><span class="hljs-comment"># 如果没有启用日志记录功能，则使用 shutil.rmtree() 方法删除日志目录，</span><br><span class="hljs-comment"># ignore_errors=True 表示忽略删除过程中的错误，如果日志目录不存在或者删除失败，也不会引发异常</span><br><span class="hljs-keyword">else</span>:<br>    shutil.rmtree(LOG_DIR, ignore_errors=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>proxypool.utils.proxy 模块: 用于检查代理是否符合 “ IP:端口 “ 格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> proxypool.schemas <span class="hljs-keyword">import</span> Proxy<br><br><br><span class="hljs-comment"># 检查给定的字符串是否符合代理格式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_proxy</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    check this string is within proxy format</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 检查给定的字符串是否是身份验证代理。如果是</span><br>    <span class="hljs-keyword">if</span> is_auth_proxy(data):<br>        <span class="hljs-comment"># 调用 extract_auth_proxy(data) 函数来获取代理的主机和端口</span><br>        host, port = extract_auth_proxy(data)<br>        <span class="hljs-comment"># 检查主机和端口是否有效，如果都有效则返回 True，否则返回 False</span><br>        <span class="hljs-keyword">return</span> is_ip_valid(host) <span class="hljs-keyword">and</span> is_port_valid(port)<br>    <span class="hljs-comment"># 如果给定的字符串不是身份验证代理，检查是否包含 &#x27;:&#x27;，如果包含</span><br>    <span class="hljs-keyword">elif</span> data.__contains__(<span class="hljs-string">&#x27;:&#x27;</span>):<br>        <span class="hljs-comment"># 使用 split() 方法获取冒号之前的部分作为 IP 地址</span><br>        ip = data.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 使用 split() 方法获取冒号之后的部分作为端口号</span><br>        port = data.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 检查 IP 地址和端口号是否有效，如果都有效则返回 True，否则返回 False</span><br>        <span class="hljs-keyword">return</span> is_ip_valid(ip) <span class="hljs-keyword">and</span> is_port_valid(port)<br>    <span class="hljs-comment"># 如果字符串既不是身份验证代理，也不包含 &#x27;:&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 直接调用 is_ip_valid() 函数检查给定的字符串是否是有效的 IP 地址，如果是则返回 True，否则返回 False</span><br>        <span class="hljs-keyword">return</span> is_ip_valid(data)<br><br><br><span class="hljs-comment"># 检查给定的字符串是否符合 IP 地址的格式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_ip_valid</span>(<span class="hljs-params">ip</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    check this string is within ip format</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 检查给定的字符串是否是身份验证代理。如果是</span><br>    <span class="hljs-keyword">if</span> is_auth_proxy(ip):<br>        <span class="hljs-comment"># 使用 split() 方法将字符串按照 &#x27;@&#x27; 分割，并取分割后的第二部分作为 IP 地址</span><br>        ip = ip.split(<span class="hljs-string">&#x27;@&#x27;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 使用 split() 方法将 IP 地址按照 &#x27;.&#x27; 分割，并将结果存储在列表 a 中</span><br>    a = ip.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    <span class="hljs-comment"># 检查 IP 地址的分割结果是否有四部分，如果不是则返回 False，因为 IPv4 地址应该由四部分组成</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) != <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 遍历 IP 地址的每一部分</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:<br>        <span class="hljs-comment"># 检查当前部分是否为数字，如果不是则返回 False，因为 IP 地址的每一部分应该是由数字组成</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x.isdigit():<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># 将当前部分转换为整数，以便后续检查</span><br>        i = <span class="hljs-built_in">int</span>(x)<br>        <span class="hljs-comment"># 检查当前部分是否在合法的范围内，即是否在 0 到 255 之间</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i &gt; <span class="hljs-number">255</span>:<br>            <span class="hljs-comment"># 如果不在范围内，则返回 False，因为每一部分的取值范围应该在 0 到 255 之间</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 如果 IP 地址的每一部分都是合法的数字且在合法范围内，则返回 True，表示该 IP 地址是有效的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># 检查端口号是否符合要求，要求端口号是一个整数值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_port_valid</span>(<span class="hljs-params">port</span>):<br>    <span class="hljs-keyword">return</span> port.isdigit()<br><br><br><span class="hljs-comment"># 将给定的字符串或字符串列表转换为有效的代理对象或代理对象列表，确保代理对象的有效性</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_proxy_or_proxies</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    convert list of str to valid proxies or proxy</span><br><span class="hljs-string">    :param data:</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 检查传入的 data 是否为空，如果是，则返回 None</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># if list of proxies</span><br>    <span class="hljs-comment"># 检查传入的 data 是否是一个列表</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">list</span>):<br>        <span class="hljs-comment"># 创建一个空列表 result 用于存储转换后的代理对象</span><br>        result = []<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:<br>            <span class="hljs-comment"># skip invalid item</span><br>            <span class="hljs-comment"># 使用 strip() 方法去除字符串两端的空格</span><br>            item = item.strip()<br>            <span class="hljs-comment"># 如果 item 不是有效的代理，就跳过该项（使用 continue）</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_valid_proxy(item): <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment"># 如果 item 是身份验证代理，使用 extract_auth_proxy() 函数获取主机和端口</span><br>            <span class="hljs-keyword">if</span> is_auth_proxy(item):<br>                host, port = extract_auth_proxy(item)<br>            <span class="hljs-comment"># 如果不是身份验证代理，直接使用 split(&#x27;:&#x27;) 方法分割字符串，并获取主机和端口</span><br>            <span class="hljs-keyword">else</span>:<br>                host, port, *_ = item.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>            <span class="hljs-comment"># 将主机和端口创建为 Proxy 对象，并添加到 result 列表中</span><br>            result.append(Proxy(host=host, port=<span class="hljs-built_in">int</span>(port)))<br>        <span class="hljs-comment"># 返回存储了代理对象的列表 result</span><br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-comment"># 如果 data 是一个字符串并且是有效的代理字符串</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">and</span> is_valid_proxy(data):<br>        <span class="hljs-comment"># 如果是身份验证代理，使用 extract_auth_proxy() 函数获取主机和端口</span><br>        <span class="hljs-keyword">if</span> is_auth_proxy(data):<br>            host, port = extract_auth_proxy(data)<br>        <span class="hljs-comment"># 如果不是身份验证代理，直接使用 split(&#x27;:&#x27;) 方法分割字符串，并获取主机和端口</span><br>        <span class="hljs-keyword">else</span>:<br>            host, port = data.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>        <span class="hljs-comment"># 将主机和端口创建为 Proxy 对象，并返回</span><br>        <span class="hljs-keyword">return</span> Proxy(host=host, port=<span class="hljs-built_in">int</span>(port))<br><br><br><span class="hljs-comment"># 检查给定的字符串是否包含 &#x27;@&#x27; 字符，从而判断是否为身份验证代理</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_auth_proxy</span>(<span class="hljs-params">data: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;@&#x27;</span> <span class="hljs-keyword">in</span> data<br><br><br><span class="hljs-comment"># 从带有身份验证的代理字符串中提取出主机和端口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_auth_proxy</span>(<span class="hljs-params">data: <span class="hljs-built_in">str</span></span>) -&gt; (<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    extract host and port from a proxy with authentication</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用 split(&#x27;@&#x27;) 方法将代理字符串按 &#x27;@&#x27; 分割，然后取分割后的第一部分，这部分是身份验证信息（如果有的话）</span><br>    auth = data.split(<span class="hljs-string">&#x27;@&#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 使用 split(&#x27;@&#x27;) 方法将代理字符串按 &#x27;@&#x27; 分割，然后取分割后的第二部分，这部分是 IP 地址和端口号信息</span><br>    ip_port = data.split(<span class="hljs-string">&#x27;@&#x27;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 使用 split(&#x27;:&#x27;) 方法将 IP 地址和端口号部分按 &#x27;:&#x27; 分割，然后取分割后的第一部分，即 IP 地址</span><br>    ip = ip_port.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 使用 split(&#x27;:&#x27;) 方法将 IP 地址和端口号部分按 &#x27;:&#x27; 分割，然后取分割后的第二部分，即端口号</span><br>    port = ip_port.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 将身份验证信息和 IP 地址合并为一个字符串，中间用 &#x27;@&#x27; 连接起来，这样就得到了完整的主机信息</span><br>    host = auth + <span class="hljs-string">&#x27;@&#x27;</span> + ip<br>    <span class="hljs-comment"># 函数返回一个元组 (host, port)，其中 host 是主机信息，port 是端口号</span><br>    <span class="hljs-keyword">return</span> host, port<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    proxy = <span class="hljs-string">&#x27;test1234:test5678.@117.68.216.212:32425&#x27;</span><br>    <span class="hljs-built_in">print</span>(extract_auth_proxy(proxy))<br></code></pre></td></tr></table></figure>



<p>首先，我们定义了一些常量，如 <code>PROXY_SCORE_MAX</code>、<code>PROXY_SCORE_MIN</code>、<code>PROXY_SCORE_INIT</code> 分别代表最大分数、最小分数、初始分数。<code>REDIS_HOST</code>、<code>REDIS_PORT</code>、<code>REDIS_PASSWORD</code> 分别代表了 Redis 的连接信息，即地址、端口和密码。<code>REDIS_KEY</code> 是有序集合的键名，我们可以通过它来获取代理存储所使用的有序集合。</p>
<p><code>RedisClient</code> 这个类可以用来操作 Redis 的有序集合，其中定义了一些方法来对集合中的元素进行处理，它的主要功能如下所示。</p>
<ul>
<li><code>__init__</code> 方法是初始化的方法，其参数是 Redis 的连接信息，默认的连接信息已经定义为常量。我们在 <code>__init__</code> 方法中初始化了 <code>StrictRedis</code> 类，建立了 Redis 连接。</li>
<li><code>add</code> 方法用于向数据库添加代理并设置分数，默认的分数是 <code>PROXY_SCORE_INIT</code>，也就是 10，返回结果是添加的结果。</li>
<li><code>random</code> 方法是随机获取代理的方法。首先获取 100 分的代理，然后随机选择一个返回。如果不存在 100 分的代理，则此方法按照排名来获取，选取前 100 名，然后随机选择一个返回，否则抛出异常。</li>
<li><code>decrease</code> 方法是在代理检测无效的时候设置分数减 1 的方法，代理传入后，此方法将代理的分数减 1，如果分数达到最低值，那么代理就删除。</li>
<li><code>exists</code> 方法用于判断代理是否存在集合中。</li>
<li><code>max</code> 方法用于将代理的分数设置为 <code>PROXY_SCORE_MAX</code>，即 100，也就是代理有效时的设置。</li>
<li><code>count</code> 方法用于返回当前集合的元素个数。</li>
<li><code>all</code> 方法返回所有的代理列表，供检测使用。</li>
</ul>
<p>定义好这些方法后，我们可以在后续的模块中调用此类来连接和操作数据库。如果要获取随机可用的代理，只需要调用 <code>random</code> 方法即可，得到的就是随机的可用代理。</p>
<p><strong>获取模块</strong></p>
<p>获取模块主要是为了从各大网站抓取代理并调用存储模块进行保存，获取模块的逻辑相对简单，proxypool.processors.getter 模块示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger  <span class="hljs-comment"># 用于记录日志</span><br><span class="hljs-keyword">from</span> proxypool.storages.redis <span class="hljs-keyword">import</span> RedisClient  <span class="hljs-comment"># 用于连接和操作 Redis 数据库的客户端</span><br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> PROXY_NUMBER_MAX  <span class="hljs-comment"># 用来设置代理池中允许的最大代理数量</span><br><span class="hljs-comment"># 从proxypool包中的crawlers模块中导入了一个名为__all__的特殊变量，</span><br><span class="hljs-comment"># 并将其重命名为crawlers_cls。__all__通常是一个列表，其中包含了模块中所有应该被导入的公共接口</span><br><span class="hljs-keyword">from</span> proxypool.crawlers <span class="hljs-keyword">import</span> __all__ <span class="hljs-keyword">as</span> crawlers_cls<br><span class="hljs-comment"># 从proxypool包中的testers模块中导入了一个名为__all__的特殊变量，并将其重命名为testers_cls</span><br><span class="hljs-keyword">from</span> proxypool.testers <span class="hljs-keyword">import</span> __all__ <span class="hljs-keyword">as</span> testers_cls<br><br><br><span class="hljs-comment"># 用于从各种来源获取代理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Getter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    getter of proxypool</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 用于初始化对象。在这里，初始化了数据库连接和爬虫实例</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        init db and crawlers</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建了一个 RedisClient 的实例，并将其赋值给 self.redis 属性，用于与 Redis 数据库进行交互</span><br>        <span class="hljs-variable language_">self</span>.redis = RedisClient()<br>        <span class="hljs-comment"># 将之前导入的爬虫类的列表（crawlers_cls）赋值给了 self.crawlers_cls 属性</span><br>        <span class="hljs-variable language_">self</span>.crawlers_cls = crawlers_cls<br>        <span class="hljs-comment"># 创建了一个包含了所有爬虫实例的列表。对于每个爬虫类，都会创建一个实例，并添加到 self.crawlers 列表中</span><br>        <span class="hljs-variable language_">self</span>.crawlers = [crawler_cls() <span class="hljs-keyword">for</span> crawler_cls <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.crawlers_cls]<br>        <span class="hljs-comment"># 将之前导入的测试器类的列表（testers_cls）赋值给了 self.testers_cls 属性</span><br>        <span class="hljs-variable language_">self</span>.testers_cls = testers_cls<br>        <span class="hljs-comment"># 创建了一个包含了所有测试器实例的列表。对于每个测试器类，都会创建一个实例，并添加到 self.testers 列表中</span><br>        <span class="hljs-variable language_">self</span>.testers = [tester_cls() <span class="hljs-keyword">for</span> tester_cls <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.testers_cls]<br><br>    <span class="hljs-comment"># 用于检查代理池是否已满</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_full</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        if proxypool if full</span><br><span class="hljs-string">        return: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 比较当前代理数量与最大代理数量（PROXY_NUMBER_MAX）来判断是否代理池已满</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.redis.count() &gt;= PROXY_NUMBER_MAX<br><br>    <span class="hljs-comment"># 应用 @logger.catch 装饰器，该方法在执行时会自动捕获可能发生的异常并记录到日志中</span><br><span class="hljs-meta">    @logger.catch</span><br>    <span class="hljs-comment"># 用于执行爬虫以获取代理</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        run crawlers to get proxy</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 检查代理池是否已满。如果代理池已满，那么方法会直接返回，不再执行后续操作</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_full():<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 遍历爬虫实例列表</span><br>        <span class="hljs-keyword">for</span> crawler <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.crawlers:<br>            <span class="hljs-comment"># 使用日志记录器记录了当前正在执行的爬虫的信息。它将爬虫的名称记录为日志的一部分，以便后续跟踪和调试</span><br>            logger.info(<span class="hljs-string">f&#x27;crawler <span class="hljs-subst">&#123;crawler&#125;</span> to get proxy&#x27;</span>)<br>            <span class="hljs-comment"># 遍历由当前爬虫实例获取的代理列表</span><br>            <span class="hljs-keyword">for</span> proxy <span class="hljs-keyword">in</span> crawler.crawl():<br>                <span class="hljs-comment"># 调用了 Redis 客户端实例的 add() 方法，将获取到的代理添加到 Redis 数据库中</span><br>                <span class="hljs-variable language_">self</span>.redis.add(proxy)<br>                <span class="hljs-comment"># 列表推导式，用于将获取到的代理添加到测试器队列中。</span><br>                <span class="hljs-comment"># 对于测试器列表中的每个测试器实例，都会调用 Redis 客户端实例的 add() 方法，将代理添加到相应的测试器的测试队列中</span><br>                [<span class="hljs-variable language_">self</span>.redis.add(proxy, redis_key=tester.key) <span class="hljs-keyword">for</span> tester <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.testers]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    getter = Getter()<br>    getter.run()<br></code></pre></td></tr></table></figure>

<p>我们可以先定义一些抓取代理的方法，比如抓取<a href="http://www.ip3366.net网站提供的代理，示例如下：">www.ip3366.net网站提供的代理，示例如下：</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> proxypool.crawlers.base <span class="hljs-keyword">import</span> BaseCrawler<br><span class="hljs-keyword">from</span> proxypool.schemas.proxy <span class="hljs-keyword">import</span> Proxy<br><span class="hljs-keyword">import</span> re<br><br><br>MAX_PAGE = <span class="hljs-number">3</span><br>BASE_URL = <span class="hljs-string">&#x27;http://www.ip3366.net/free/?stype=&#123;stype&#125;&amp;page=&#123;page&#125;&#x27;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IP3366Crawler</span>(<span class="hljs-title class_ inherited__">BaseCrawler</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    ip3366 crawler, http://www.ip3366.net/</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    urls = [BASE_URL.<span class="hljs-built_in">format</span>(stype=stype,page=i) <span class="hljs-keyword">for</span> stype <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, html</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        parse html file to get proxies</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ip_address = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;&lt;tr&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;&#x27;</span>)<br>        <span class="hljs-comment"># \s * 匹配空格，起到换行作用</span><br>        re_ip_address = ip_address.findall(html)<br>        <span class="hljs-keyword">for</span> address, port <span class="hljs-keyword">in</span> re_ip_address:<br>            proxy = Proxy(host=address.strip(), port=<span class="hljs-built_in">int</span>(port.strip()))<br>            <span class="hljs-keyword">yield</span> proxy<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    crawler = IP3366Crawler()<br>    <span class="hljs-keyword">for</span> proxy <span class="hljs-keyword">in</span> crawler.crawl():<br>        <span class="hljs-built_in">print</span>(proxy)<br></code></pre></td></tr></table></figure>

<p>这里定义了一个代理类 <code>Crawler</code>，用来抓取某一网站的代理，这里抓取的是 IP3366 的公开代理，通过 <code>parse</code> 方法来解析页面的源码并构造一个个 Proxy 对象返回即可。</p>
<p>另外，在其父类 <code>BaseCrawler</code> 里面定义了通用的页面抓取方法，它可以读取子类里面定义的 <code>urls</code> 全局变量并进行爬取，然后调用子类的 <code>parse</code> 方法来解析页面，代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从 retrying 库中导入了 RetryError 异常和 retry 装饰器。RetryError 用于表示重试操作失败时抛出的异常，而 retry 装饰器用于定义一个可以自动重试的函数或方法</span><br><span class="hljs-keyword">from</span> retrying <span class="hljs-keyword">import</span> RetryError, retry<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<br><span class="hljs-comment"># 从 proxypool.setting 模块中导入了 GET_TIMEOUT 常量，该常量表示发送 HTTP 请求的超时时间</span><br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> GET_TIMEOUT<br><span class="hljs-comment"># 导入了 Headers 类，用于生成随机的用户代理和其他请求头信息</span><br><span class="hljs-keyword">from</span> fake_headers <span class="hljs-keyword">import</span> Headers<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseCrawler</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-comment"># 用于存储要爬取的目标 URL 列表</span><br>    urls = []<br><br>    <span class="hljs-comment"># 这是一个装饰器，用于装饰 fetch() 方法。它表示在遇到特定的异常或返回结果为 None 时，最多重试 3 次，重试间隔固定为 2000 毫秒</span><br><span class="hljs-meta">    @retry(<span class="hljs-params">stop_max_attempt_number=<span class="hljs-number">3</span>, retry_on_result=<span class="hljs-keyword">lambda</span> x: x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, wait_fixed=<span class="hljs-number">2000</span></span>)</span><br>    <span class="hljs-comment"># 用于从指定的 URL 获取网页内容。它接受一个 URL 参数和其他可选的关键字参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">self, url, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 使用 fake_headers 库生成随机的用户代理和其他请求头信息</span><br>            headers = Headers(headers=<span class="hljs-literal">True</span>).generate()<br>            <span class="hljs-comment"># 设置了默认的超时时间，如果用户没有指定超时时间，则使用 GET_TIMEOUT 常量的值</span><br>            kwargs.setdefault(<span class="hljs-string">&#x27;timeout&#x27;</span>, GET_TIMEOUT)<br>            kwargs.setdefault(<span class="hljs-string">&#x27;verify&#x27;</span>, <span class="hljs-literal">False</span>)<br>            kwargs.setdefault(<span class="hljs-string">&#x27;headers&#x27;</span>, headers)<br>            <span class="hljs-comment"># 发送了一个 HTTP GET 请求，并获取响应对象</span><br>            response = requests.get(url, **kwargs)<br>            <span class="hljs-comment"># 检查响应的状态码是否为 200，表示请求成功</span><br>            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-comment"># 设置了响应的编码为 UTF-8</span><br>                response.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>                <span class="hljs-comment"># 返回响应的文本内容</span><br>                <span class="hljs-keyword">return</span> response.text<br>        <span class="hljs-keyword">except</span> (requests.ConnectionError, requests.ReadTimeout):<br>            <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 用于解析 HTML 内容。它接受两个参数：HTML 内容和相关的 URL</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">self, html, url</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        used for parse html</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> proxy <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.parse(html):<br>            logger.info(<span class="hljs-string">f&#x27;fetched proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> from <span class="hljs-subst">&#123;url&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># 使用生成器将解析得到的代理逐个返回</span><br>            <span class="hljs-keyword">yield</span> proxy<br><br>    <span class="hljs-comment"># 用于执行爬取的主要逻辑</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        crawl main method</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 遍历存储在 urls 类变量中的目标 URL 列表</span><br>            <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.urls:<br>                logger.info(<span class="hljs-string">f&#x27;fetching <span class="hljs-subst">&#123;url&#125;</span>&#x27;</span>)<br>                <span class="hljs-comment"># 调用 fetch() 方法获取指定 URL 的网页内容</span><br>                html = <span class="hljs-variable language_">self</span>.fetch(url)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> html:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment"># 这行代码使程序休眠 0.5 秒，用于限制爬取频率</span><br>                time.sleep(<span class="hljs-number">.5</span>)<br>                <span class="hljs-comment"># 使用生成器将解析得到的代理逐个返回</span><br>                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> <span class="hljs-variable language_">self</span>.process(html, url)<br>        <span class="hljs-comment"># 异常处理块，用于捕获重试操作失败时抛出的 RetryError 异常</span><br>        <span class="hljs-keyword">except</span> RetryError:<br>            logger.error(<br>                <span class="hljs-string">f&#x27;crawler <span class="hljs-subst">&#123;self&#125;</span> crawled proxy unsuccessfully, &#x27;</span><br>                <span class="hljs-string">&#x27;please check if target url is valid or network issue&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>如果要扩展一个代理的 <code>Crawler</code>，只需要集成 <code>BaseCrawler</code> 并实现 <code>parse</code> 方法即可，扩展性较好。</p>
<p>因此，这一个个的 <code>Crawler</code> 就可以针对各个不同的代理网站进行代理的抓取。最后，有一个统一的方法将 <code>Crawler</code> 汇总起来，遍历调用即可。</p>
<p>如何汇总呢？这里我们可以检测代码只要定义有 <code>BaseCrawler</code> 的子类就算一个有效的代理 <code>Crawler</code>，可以直接通过遍历 Python 文件包的方式来获取，代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于处理包和模块的工具用于处理包和模块的工具</span><br><span class="hljs-keyword">import</span> pkgutil<br><span class="hljs-keyword">from</span> .base <span class="hljs-keyword">import</span> BaseCrawler<br><span class="hljs-comment"># 用于检查对象的属性和方法</span><br><span class="hljs-keyword">import</span> inspect<br><br><br><span class="hljs-comment"># load classes subclass of BaseCrawler</span><br><span class="hljs-comment"># 创建了一个空列表，用于存储找到的类</span><br>classes = []<br><span class="hljs-comment"># 使用 pkgutil.walk_packages() 函数遍历当前包中的所有模块。__path__ 是一个特殊变量，包含了当前包的路径</span><br><span class="hljs-keyword">for</span> loader, name, is_pkg <span class="hljs-keyword">in</span> pkgutil.walk_packages(__path__):<br>    <span class="hljs-comment"># 使用 loader.find_module() 找到模块，然后使用 load_module() 加载模块。这样做可以动态地加载模块</span><br>    module = loader.find_module(name).load_module(name)<br>    <span class="hljs-comment"># 对加载的模块使用 inspect.getmembers() 获取模块中的所有成员</span><br>    <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> inspect.getmembers(module):<br>        <span class="hljs-comment"># 将加载的模块中的每个成员添加到全局命名空间中</span><br>        <span class="hljs-built_in">globals</span>()[name] = value<br>        <span class="hljs-comment"># 检查成员是否是一个类，并且是 BaseCrawler 的子类，且不是 BaseCrawler 本身</span><br>        <span class="hljs-comment"># 同时确保该类没有设置 ignore 属性或者 ignore 属性为 False</span><br>        <span class="hljs-keyword">if</span> inspect.isclass(value) <span class="hljs-keyword">and</span> <span class="hljs-built_in">issubclass</span>(value, BaseCrawler) <span class="hljs-keyword">and</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> BaseCrawler \<br>                <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">getattr</span>(value, <span class="hljs-string">&#x27;ignore&#x27;</span>, <span class="hljs-literal">False</span>):<br>            <span class="hljs-comment"># 如果成员满足条件，将其添加到 classes 列表中</span><br>            classes.append(value)<br><span class="hljs-comment"># 将 classes 列表赋值给特殊变量 __all__ 和 __ALL__，这样在模块导入时，其他模块可以通过 from module import * 导入所有在 classes 列表中的类</span><br>__all__ = __ALL__ = classes<br></code></pre></td></tr></table></figure>

<p>这里我们调用了 <code>walk_packages</code> 方法，遍历了整个 crawlers 模块下的类，并判断它是 <code>BaseCrawler</code> 的子类，那就将其添加到结果中并返回。</p>
<p>最后，只要将 <code>classes</code> 遍历并依次实例化，调用其 <code>crawl</code> 方法即可完成代理的爬取和提取。</p>
<p><strong>检测模块</strong></p>
<p>我们已经成功将各个网站的代理获取下来了，现在需要一个检测模块来对所有代理进行多轮检测。代理检测可用，分数就设置为 100，代理不可用，分数就减 1，这样可以实时改变每个代理的可用情况。如果要获取有效代理，只需要获取分数高的代理即可。</p>
<p>由于代理的数量非常多，为了提高代理的检测效率，这里使用异步请求库 aiohttp 来检测。</p>
<p>requests 作为一个同步请求库，我们在发出一个请求之后，程序需要等待网页加载完成之后才能继续执行。也就是这个过程会阻塞等待响应，如果服务器响应非常慢，比如一个请求等待十几秒，那么我们使用 requests 完成一个请求就会需要十几秒的时间，程序也不会继续往下执行，而在这十几秒的时间里，程序其实完全可以去做其他的事情，比如调度其他的请求或者进行网页解析等。</p>
<p>对于响应速度比较快的网站来说，requests 同步请求和 aiohttp 异步请求的效果差距没那么大。可对于检测代理来说，检测一个代理一般需要十多秒甚至几十秒的时间，这时候使用 aiohttp 异步请求库的优势就大大体现出来了，效率可能会提高几十倍不止。</p>
<p>所以，我们的代理检测使用异步请求库 aiohttp，proxypool.processors.tester 模块实现示例如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio  <span class="hljs-comment"># 用于异步编程</span><br><span class="hljs-keyword">import</span> aiohttp  <span class="hljs-comment"># 用于异步 HTTP 客户端</span><br><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger  <span class="hljs-comment"># 用于日志记录</span><br><span class="hljs-keyword">from</span> proxypool.schemas <span class="hljs-keyword">import</span> Proxy  <span class="hljs-comment"># 用于表示代理对象</span><br><span class="hljs-keyword">from</span> proxypool.storages.redis <span class="hljs-keyword">import</span> RedisClient  <span class="hljs-comment"># 用于与 Redis 数据库交互</span><br><span class="hljs-comment"># 从 setting 模块中导入一些常量，如测试代理的超时时间、批量测试数量、测试URL、有效的响应状态码、是否匿名代理以及是否不设置最大分数等</span><br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> TEST_TIMEOUT, TEST_BATCH, TEST_URL, TEST_VALID_STATUS, TEST_ANONYMOUS, \<br>    TEST_DONT_SET_MAX_SCORE<br><span class="hljs-comment"># 从 aiohttp 库中导入一些可能的异常类，如客户端代理连接错误、服务器断开连接错误、客户端操作系统错误和客户端 HTTP 代理错误等</span><br><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientProxyConnectionError, ServerDisconnectedError, ClientOSError, ClientHttpProxyError<br><span class="hljs-keyword">from</span> asyncio <span class="hljs-keyword">import</span> TimeoutError  <span class="hljs-comment"># 导入超时异常类</span><br><span class="hljs-keyword">from</span> proxypool.testers <span class="hljs-keyword">import</span> __all__ <span class="hljs-keyword">as</span> testers_cls  <span class="hljs-comment"># 导入测试模块中定义的所有测试类，这些类用于对代理进行验证</span><br><br><span class="hljs-comment"># 包含了可能发生的各种异常类型，用于在测试代理时进行异常处理</span><br>EXCEPTIONS = (<br>    ClientProxyConnectionError,<br>    ConnectionRefusedError,<br>    TimeoutError,<br>    ServerDisconnectedError,<br>    ClientOSError,<br>    ClientHttpProxyError,<br>    AssertionError<br>)<br><br><br><span class="hljs-comment"># 用于测试代理的有效性，通过异步方式测试代理的有效性，并将测试结果记录到日志中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tester</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    tester for testing proxies in queue</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 用于初始化对象的属性。在这里，它初始化了 redis 客户端、事件循环、测试器类列表等</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        init redis</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.redis = RedisClient()  <span class="hljs-comment"># 这个对象用于与 Redis 数据库进行交互，从中获取代理并存储测试结果</span><br>        <span class="hljs-variable language_">self</span>.loop = asyncio.get_event_loop()  <span class="hljs-comment"># 事件循环是异步编程中用于调度和执行异步任务的核心组件</span><br>        <span class="hljs-variable language_">self</span>.testers_cls = testers_cls  <span class="hljs-comment"># 这些测试类在之前的代码中被导入，并在测试过程中用于额外的测试</span><br>        <span class="hljs-variable language_">self</span>.testers = [tester_cls() <span class="hljs-keyword">for</span> tester_cls <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.testers_cls]  <span class="hljs-comment"># 对 self.testers_cls 中的每个测试器类实例化一个对象，并将其添加到列表中</span><br><br>    <span class="hljs-comment"># 用于测试单个代理的有效性。它接受一个 Proxy 对象作为参数，并在异步上下文中使用 aiohttp 客户端会话来测试代理的有效性</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self, proxy: Proxy</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        test single proxy</span><br><span class="hljs-string">        :param proxy: Proxy object</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 这是一个异步上下文管理器，用于创建一个 aiohttp 的客户端会话对象 session。在这个会话中，我们可以发送 HTTP 请求来测试代理的有效性</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=<span class="hljs-literal">False</span>)) <span class="hljs-keyword">as</span> session:<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 记录调试级别的日志，表示正在测试特定代理。proxy.string() 是 Proxy 对象的方法，用于获取代理的字符串表示形式</span><br>                logger.debug(<span class="hljs-string">f&#x27;testing <span class="hljs-subst">&#123;proxy.string()&#125;</span>&#x27;</span>)<br>                <span class="hljs-comment"># if TEST_ANONYMOUS is True, make sure that</span><br>                <span class="hljs-comment"># the proxy has the effect of hiding the real IP</span><br>                <span class="hljs-comment"># 条件判断，检查是否需要测试代理的匿名性。如果设置了 TEST_ANONYMOUS 为 True，则需要验证代理是否可以隐藏真实 IP</span><br>                <span class="hljs-keyword">if</span> TEST_ANONYMOUS:<br>                    url = <span class="hljs-string">&#x27;https://httpbin.org/ip&#x27;</span><br>                    <span class="hljs-comment"># 异步上下文管理器，用于发送 HTTP GET 请求来获取指定 URL 的响应。在这里，我们首先获取未经代理的请求的响应，以获得真实 IP 地址</span><br>                    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, timeout=TEST_TIMEOUT) <span class="hljs-keyword">as</span> response:<br>                        resp_json = <span class="hljs-keyword">await</span> response.json()<br>                        origin_ip = resp_json[<span class="hljs-string">&#x27;origin&#x27;</span>]<br>                    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=<span class="hljs-string">f&#x27;http://<span class="hljs-subst">&#123;proxy.string()&#125;</span>&#x27;</span>, timeout=TEST_TIMEOUT) <span class="hljs-keyword">as</span> response:<br>                        resp_json = <span class="hljs-keyword">await</span> response.json()<br>                        anonymous_ip = resp_json[<span class="hljs-string">&#x27;origin&#x27;</span>]<br>                    <span class="hljs-comment"># 断言语句，用于确保未经代理的请求和经过代理的请求的 IP 地址不相同，以验证代理是否隐藏了真实 IP</span><br>                    <span class="hljs-keyword">assert</span> origin_ip != anonymous_ip<br>                    <span class="hljs-comment"># 断言语句，用于确保经过代理的请求的 IP 地址与代理的 IP 地址相同，以确保代理成功起作用</span><br>                    <span class="hljs-keyword">assert</span> proxy.host == anonymous_ip<br>                <span class="hljs-comment"># 异步上下文管理器，用于发送 HTTP GET 请求来测试代理的响应。在这里，我们使用代理来访问指定的测试 URL，以测试代理是否能够成功连接和响应</span><br>                <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(TEST_URL, proxy=<span class="hljs-string">f&#x27;http://<span class="hljs-subst">&#123;proxy.string()&#125;</span>&#x27;</span>, timeout=TEST_TIMEOUT,<br>                                       allow_redirects=<span class="hljs-literal">False</span>) <span class="hljs-keyword">as</span> response:<br>                    <span class="hljs-keyword">if</span> response.status <span class="hljs-keyword">in</span> TEST_VALID_STATUS:<br>                        <span class="hljs-keyword">if</span> TEST_DONT_SET_MAX_SCORE:<br>                            logger.debug(<span class="hljs-string">f&#x27;proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is valid, remain current score&#x27;</span>)<br>                        <span class="hljs-keyword">else</span>:<br>                            <span class="hljs-variable language_">self</span>.redis.<span class="hljs-built_in">max</span>(proxy)<br>                            logger.debug(<span class="hljs-string">f&#x27;proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is valid, set max score&#x27;</span>)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-variable language_">self</span>.redis.decrease(proxy)<br>                        logger.debug(<span class="hljs-string">f&#x27;proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is invalid, decrease score&#x27;</span>)<br>                <span class="hljs-comment"># if independent tester class found, create new set of storage and do the extra test</span><br>                <span class="hljs-comment"># 遍历所有的测试器对象。在这个循环中，我们对每个测试器执行额外的测试，并根据测试结果调整代理的分数</span><br>                <span class="hljs-keyword">for</span> tester <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.testers:<br>                    key = tester.key<br>                    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.redis.exists(proxy, key):<br>                        test_url = tester.test_url<br>                        headers = tester.headers()<br>                        cookies = tester.cookies()<br>                        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(test_url, proxy=<span class="hljs-string">f&#x27;http://<span class="hljs-subst">&#123;proxy.string()&#125;</span>&#x27;</span>,<br>                                               timeout=TEST_TIMEOUT,<br>                                               headers=headers,<br>                                               cookies=cookies,<br>                                               allow_redirects=<span class="hljs-literal">False</span>) <span class="hljs-keyword">as</span> response:<br>                            resp_text = <span class="hljs-keyword">await</span> response.text()<br>                            is_valid = <span class="hljs-keyword">await</span> tester.parse(resp_text, test_url, proxy.string())<br>                            <span class="hljs-keyword">if</span> is_valid:<br>                                <span class="hljs-keyword">if</span> tester.test_dont_set_max_score:<br>                                    logger.info(<span class="hljs-string">f&#x27;key[<span class="hljs-subst">&#123;key&#125;</span>] proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is valid, remain current score&#x27;</span>)<br>                                <span class="hljs-keyword">else</span>:<br>                                    <span class="hljs-variable language_">self</span>.redis.<span class="hljs-built_in">max</span>(proxy, key, tester.proxy_score_max)<br>                                    logger.info(<span class="hljs-string">f&#x27;key[<span class="hljs-subst">&#123;key&#125;</span>] proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is valid, set max score&#x27;</span>)<br>                            <span class="hljs-keyword">else</span>:<br>                                <span class="hljs-variable language_">self</span>.redis.decrease(proxy, tester.key, tester.proxy_score_min)<br>                                logger.info(<span class="hljs-string">f&#x27;key[<span class="hljs-subst">&#123;key&#125;</span>] proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is invalid, decrease score&#x27;</span>)<br><br>            <span class="hljs-comment"># 捕获可能发生的异常。如果发生异常，则将代理的分数降低，并针对每个测试器也将分数降低</span><br>            <span class="hljs-keyword">except</span> EXCEPTIONS:<br>                <span class="hljs-variable language_">self</span>.redis.decrease(proxy)<br>                [<span class="hljs-variable language_">self</span>.redis.decrease(proxy, tester.key, tester.proxy_score_min) <span class="hljs-keyword">for</span> tester <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.testers]<br>                logger.debug(<span class="hljs-string">f&#x27;proxy <span class="hljs-subst">&#123;proxy.string()&#125;</span> is invalid, decrease score&#x27;</span>)<br><br>    <span class="hljs-comment"># 这是一个装饰器，用于捕获方法中的异常，并将异常信息记录到日志中</span><br><span class="hljs-meta">    @logger.catch</span><br>    <span class="hljs-comment"># 用于执行代理测试的主要逻辑。它首先获取待测试代理的数量，并使用游标批量获取待测试的代理。然后，针对每个代理启动一个异步任务进行测试，直到所有代理都被测试完毕</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        test main method</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># event loop of aiohttp</span><br>        <span class="hljs-comment"># 记录信息级别的日志，表示开始执行代理测试</span><br>        logger.info(<span class="hljs-string">&#x27;stating tester...&#x27;</span>)<br>        <span class="hljs-comment"># 调用 Redis 客户端的 count() 方法获取当前代理池中代理的数量</span><br>        count = <span class="hljs-variable language_">self</span>.redis.count()<br>        <span class="hljs-comment"># 记录调试级别的日志，表示有多少个代理需要被测试</span><br>        logger.debug(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;count&#125;</span> proxies to test&#x27;</span>)<br>        <span class="hljs-comment"># 初始化游标为 0，用于批量获取代理</span><br>        cursor = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 无限循环，用于持续执行代理测试的逻辑，直到所有代理都被测试完毕</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            logger.debug(<span class="hljs-string">f&#x27;testing proxies use cursor <span class="hljs-subst">&#123;cursor&#125;</span>, count <span class="hljs-subst">&#123;TEST_BATCH&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># 调用 Redis 客户端的 batch() 方法批量获取代理。它返回一个新的游标和一批代理列表</span><br>            cursor, proxies = <span class="hljs-variable language_">self</span>.redis.batch(cursor, count=TEST_BATCH)<br>            <span class="hljs-comment"># 检查是否存在待测试的代理。如果存在，则创建异步任务列表 tasks，其中每个任务都是调用 test() 方法测试一个代理</span><br>            <span class="hljs-keyword">if</span> proxies:<br>                tasks = [<span class="hljs-variable language_">self</span>.loop.create_task(<span class="hljs-variable language_">self</span>.test(proxy)) <span class="hljs-keyword">for</span> proxy <span class="hljs-keyword">in</span> proxies]<br>                <span class="hljs-comment"># 运行事件循环，直到所有的异步任务都完成。asyncio.wait(tasks) 是一个协程，用于等待所有的异步任务完成</span><br>                <span class="hljs-variable language_">self</span>.loop.run_until_complete(asyncio.wait(tasks))<br>            <span class="hljs-comment"># 检查是否已经遍历完所有的代理。如果游标为 0，表示所有的代理都已经被遍历完毕，此时退出循环</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cursor:<br>                <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_tester</span>():<br>    host = <span class="hljs-string">&#x27;96.113.165.182&#x27;</span><br>    port = <span class="hljs-string">&#x27;3128&#x27;</span><br>    <span class="hljs-comment"># 创建了一个包含单个测试任务的任务列表 tasks。测试任务通过调用 tester 对象的 test() 方法来测试一个指定的代理，而代理信息是通过创建一个 Proxy 对象来指定的</span><br>    tasks = [tester.test(Proxy(host=host, port=port))]<br>    tester.loop.run_until_complete(asyncio.wait(tasks))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    tester = Tester()<br>    tester.run()<br>    <span class="hljs-comment"># run_tester()</span><br></code></pre></td></tr></table></figure>

<p>相关模块：</p>
<p>proxypool.testers 模块: 用于测试代理的有效性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从 proxypool.setting 模块中导入了一些常量，包括是否不设置最大分数、代理初始分数、代理最大分数和代理最小分数</span><br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> TEST_DONT_SET_MAX_SCORE, PROXY_SCORE_INIT, PROXY_SCORE_MAX, PROXY_SCORE_MIN<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseTester</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-comment"># 用于存储要测试的目标 URL，默认为空字符串</span><br>    test_url = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># 用于存储代理存储的键，默认为空字符串</span><br>    key = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment"># 用于指示是否不设置最大分数的标志，默认为从常量 TEST_DONT_SET_MAX_SCORE 中获取</span><br>    test_dont_set_max_score = TEST_DONT_SET_MAX_SCORE<br>    <span class="hljs-comment"># 用于存储代理的初始分数，默认为从常量 PROXY_SCORE_INIT 中获取</span><br>    proxy_score_init = PROXY_SCORE_INIT<br>    <span class="hljs-comment"># 用于存储代理的最大分数，默认为从常量 PROXY_SCORE_MAX 中获取</span><br>    proxy_score_max = PROXY_SCORE_MAX<br>    <span class="hljs-comment"># 用于存储代理的最小分数，默认为从常量 PROXY_SCORE_MIN 中获取</span><br>    proxy_score_min = PROXY_SCORE_MIN<br><br>    <span class="hljs-comment"># 用于返回 HTTP 请求的头部信息，默认为空</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">headers</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 用于返回 HTTP 请求的 cookie 信息，默认为空</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cookies</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 这是一个异步方法，用于解析 HTML 内容，判断代理是否有效。它接受 HTML 内容、URL、代理和表达式参数，表达式用于判断代理是否有效，</span><br>    <span class="hljs-comment"># 默认为 &#123;&quot;code&quot;:0&#125;。如果表达式在 HTML 内容中找到了，则返回 True，表示代理有效；否则返回 False，表示代理无效</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, html, url, proxy, expr=<span class="hljs-string">&#x27;&#123;&quot;code&quot;:0&#x27;</span></span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> expr <span class="hljs-keyword">in</span> html <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<p>这里定义了一个类 <code>Tester</code>，<code>__init__</code> 方法中建立了一个 <code>RedisClient</code> 对象，供该对象中其他方法使用。接下来，定义了一个 <code>test</code> 方法，这个方法用来检测单个代理的可用情况，其参数就是被检测的代理。注意，<code>test</code> 方法前面加了 <code>async</code> 关键词，这代表这个方法是异步的。方法内部首先创建了 aiohttp 的 <code>ClientSession</code> 对象，可以直接调用该对象的 <code>get</code> 方法来访问页面。</p>
<p>测试链接在这里定义为常量 <code>TEST_URL</code>。如果针对某个网站有访问需求，建议将 <code>TEST_URL</code> 设置为目标网站的地址，因为在访问过程中，代理本身可能是可用的，但是该代理的 IP 已经被目标网站封掉了。例如，某些代理可以正常访问百度等页面，但是对知乎来说可能就被封了，所以我们可以将 <code>TEST_URL</code> 设置为知乎的某个页面的链接。当请求失败、代理被封时，分数自然会减下来，失效的代理就不会被取到了。</p>
<p>如果想做一个通用的代理池，则不需要专门设置 <code>TEST_URL</code>，既可以将其设置为一个不会封 IP 的网站，也可以设置为百度这类响应稳定的网站。</p>
<p>我们还定义了 <code>TEST_VALID_STATUS</code> 变量，这个变量是一个列表形式，包含了正常的状态码，如可以定义成 <code>[200]</code>。当然，某些目标网站可能会出现其他的状态码，可以自行配置。</p>
<p>程序在获取响应后需要判断响应的状态，如果状态码在 <code>TEST_VALID_STATUS</code> 列表里，则代表代理可用，可以调用 <code>RedisClient</code> 的 <code>max</code> 方法将代理分数设为 100，否则调用 <code>decrease</code> 方法将代理分数减 1，如果出现异常，也同样将代理分数减 1。</p>
<p>另外，我们设置了批量测试的最大值 <code>TEST_BATCH</code>，也就是一批测试最多 <code>TEST_BATCH</code> 个，这可以避免代理池过大时一次性测试全部代理导致内存开销过大的问题。当然，也可以用信号量来实现并发控制。</p>
<p>随后，在 <code>run</code> 方法里面获取了所有的代理列表，使用 aiohttp 分配任务，启动运行。这样在不断的运行过程中，代理池中无效代理的分数会一直被减 1，直至被清除，有效的代理则会一直保持 100 分，供随时取用。</p>
<p>这样测试模块的逻辑就完成了。</p>
<p><strong>接口模块</strong></p>
<p>通过上述 3 个模块，我们已经可以做到代理的获取、检测和更新，数据库就会以有序集合的形式存储各个代理及其对应的分数，分数 100 代表可用，分数越小代表越不可用。</p>
<p>但是我们怎样方便地获取可用代理呢？可以用 <code>RedisClient</code> 类直接连接 Redis，然后调用 <code>random</code> 方法。这样做没问题，效率很高，但是会有两个弊端。</p>
<ul>
<li>如果其他人使用这个代理池，他需要知道 Redis 连接的用户名和密码信息，这样很不安全。</li>
<li>如果代理池需要部署在远程服务器上运行，而远程服务器的 Redis 只允许本地连接，那么我们就不能远程直连 Redis 来获取代理。</li>
</ul>
<p>综上考虑，为了使代理池可以作为一个独立服务运行，我们最好增加一个接口模块，并以 Web API 的形式暴露可用代理。</p>
<p>这样一来，获取代理只需要请求接口即可，以上的两个缺点也可以避免。</p>
<p>我们使用一个比较轻量级的库 Flask 来实现这个接口模块，proxypool.processors.server 模块实现示例如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从 Flask 框架中导入了 Flask 类以及一些其他的辅助工具，如 g（用于存储每个请求的全局变量）和 request（用于处理 HTTP 请求）</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, g, request<br><span class="hljs-comment"># 导入了一个自定义的异常类 PoolEmptyException，在代理池模块中定义的用于处理代理池耗尽的异常</span><br><span class="hljs-keyword">from</span> proxypool.exceptions <span class="hljs-keyword">import</span> PoolEmptyException<br><span class="hljs-comment"># 导入了一个用于与 Redis 数据库交互的客户端类 RedisClient，用于代理池的存储和管理</span><br><span class="hljs-keyword">from</span> proxypool.storages.redis <span class="hljs-keyword">import</span> RedisClient<br><span class="hljs-comment"># 从 setting 模块中导入了一些常量，这些常量可能用于配置应用程序的不同参数，如 API 主机、端口、是否多线程等</span><br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> API_HOST, API_PORT, API_THREADED, API_KEY, IS_DEV, PROXY_RAND_KEY_DEGRADED<br><span class="hljs-comment"># 导入了 Python 内置的 functools 模块，它通常用于高阶函数的操作</span><br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-comment"># 定义了一个叫做 __all__ 的特殊变量，它指定了在模块导入时可以被导入的公共接口，这里只有一个 app 对象</span><br>__all__ = [<span class="hljs-string">&#x27;app&#x27;</span>]<br><br><span class="hljs-comment"># 创建了一个 Flask 应用程序对象，并将其赋值给变量 app。__name__ 参数表示当前模块的名称，Flask 使用这个参数来确定静态文件的目录位置等</span><br>app = Flask(__name__)<br><span class="hljs-comment"># 根据一个名为 IS_DEV 的常量的值来设置 Flask 应用程序的调试模式。如果 IS_DEV 为真，则将调试模式开启</span><br><span class="hljs-keyword">if</span> IS_DEV:<br>    app.debug = <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># 定义了一个装饰器函数 auth_required，用于保护需要授权访问的路由或视图函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">auth_required</span>(<span class="hljs-params">func</span>):  <span class="hljs-comment"># 接受一个函数 func 作为参数，该函数通常是需要保护的视图函数或路由处理函数</span><br>    <span class="hljs-comment">#  这是一个装饰器，用于确保被装饰的函数保留其元数据（如名称、文档字符串等）。这是为了确保被装饰的函数在被调试或文档化时能够正确显示</span><br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-comment"># 这是内部定义的装饰器函数，它接受任意数量的位置参数 args 和关键字参数 kwargs，用于传递给被装饰的函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># conditional decorator, when setting API_KEY is set, otherwise just ignore this decorator</span><br>        <span class="hljs-comment"># 检查是否设置了 API_KEY。如果未设置 API_KEY，则直接调用被装饰的函数，并返回其结果，意味着不需要进行认证，直接通过</span><br>        <span class="hljs-keyword">if</span> API_KEY == <span class="hljs-string">&quot;&quot;</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-comment"># 尝试从请求头中获取 API-KEY，如果存在，则将其存储在 api_key 变量中</span><br>        <span class="hljs-keyword">if</span> request.headers.get(<span class="hljs-string">&#x27;API-KEY&#x27;</span>, <span class="hljs-literal">None</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            api_key = request.headers.get(<span class="hljs-string">&#x27;API-KEY&#x27;</span>)<br>        <span class="hljs-comment"># 如果请求头中未提供 API-KEY，则返回一个包含错误消息的响应，并将状态码设置为 400（Bad Request）</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Please provide an API key in header&quot;</span>&#125;, <span class="hljs-number">400</span><br>        <span class="hljs-comment"># Check if API key is correct and valid</span><br>        <span class="hljs-comment"># 检查请求的方法是否为 GET，同时检查 API_KEY 是否与设置的 API_KEY 匹配。如果条件满足，则调用被装饰的函数，并返回其结果</span><br>        <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&quot;GET&quot;</span> <span class="hljs-keyword">and</span> api_key == API_KEY:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-comment"># 如果条件不满足，则返回一个包含错误消息的响应，并将状态码设置为 403（Forbidden）</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;The provided API key is not valid&quot;</span>&#125;, <span class="hljs-number">403</span><br><br>    <span class="hljs-comment"># 装饰器函数返回内部定义的 decorator 函数，以便应用于需要进行认证的视图函数或路由</span><br>    <span class="hljs-keyword">return</span> decorator<br><br><br><span class="hljs-comment"># 用于获取 Redis 客户端对象。函数首先检查全局变量 g 是否具有属性 redis，如果没有，则实例化一个 RedisClient 对象，并将其存储在 g.redis 中。最后返回 g.redis</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_conn</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    get redis client object</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(g, <span class="hljs-string">&#x27;redis&#x27;</span>):<br>        g.redis = RedisClient()<br>    <span class="hljs-keyword">return</span> g.redis<br><br><br><span class="hljs-comment"># 这是一个装饰器，用于将下面定义的 index 函数与根路径 / 绑定。这意味着当用户访问根路径时，将会执行 index 函数</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-comment"># 这是一个装饰器，用于对 index 函数进行认证。它会确保只有在经过认证的情况下才能访问 index 函数。具体的认证逻辑由之前定义的 auth_required 装饰器提供</span><br><span class="hljs-meta">@auth_required</span><br><span class="hljs-comment"># 路由处理函数。当用户访问根路径时，该函数会被调用。函数返回一个简单的 HTML 字符串 &lt;h2&gt;Welcome to Proxy Pool System&lt;/h2&gt;，用于显示欢迎消息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    get home page, you can define your own templates</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;h2&gt;Welcome to Proxy Pool System&lt;/h2&gt;&#x27;</span><br><br><br><span class="hljs-comment"># 这是一个装饰器，将下面定义的 get_proxy 函数与路径 /random 绑定。因此，当用户访问 /random 路径时，将执行 get_proxy 函数</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/random&#x27;</span></span>)</span><br><span class="hljs-comment"># 这是一个装饰器，用于对 get_proxy 函数进行认证。它确保只有经过认证的用户才能访问 get_proxy 函数</span><br><span class="hljs-meta">@auth_required</span><br><span class="hljs-comment"># 路由处理函数。当用户访问 /random 路径时，该函数会被调用</span><br><span class="hljs-comment"># 作用是从代理池中获取一个随机的代理，并根据查询参数 key 指定的子池来进行选择。如果代理池为空，根据配置决定是否抛出异常或者返回整个代理池的随机代理</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    get a random proxy, can query the specific sub-pool according the (redis) key</span><br><span class="hljs-string">    if PROXY_RAND_KEY_DEGRADED is set to True, will get a universal random proxy if no proxy found in the sub-pool</span><br><span class="hljs-string">    :return: get a random proxy</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 从 HTTP 请求的查询参数中获取名为 key 的值，这个值用于指定要查询的代理池的子池（如果有的话）</span><br>    key = request.args.get(<span class="hljs-string">&#x27;key&#x27;</span>)<br>    <span class="hljs-comment"># 调用 get_conn 函数获取 Redis 客户端连接对象</span><br>    conn = get_conn()<br>    <span class="hljs-comment"># return conn.random(key).string() if key else conn.random().string()</span><br>    <span class="hljs-keyword">if</span> key:<br>        <span class="hljs-comment"># 尝试从代理池中获取一个随机的代理。如果指定了 key，则尝试从该子池中获取；否则，从整个代理池中获取。如果代理池为空，</span><br>        <span class="hljs-comment"># 且未设置 PROXY_RAND_KEY_DEGRADED 为 True，则抛出异常 PoolEmptyException</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> conn.random(key).string()<br>        <span class="hljs-keyword">except</span> PoolEmptyException:<br>            <span class="hljs-comment"># 如果代理池为空，并且未设置 PROXY_RAND_KEY_DEGRADED 为 True，则抛出 PoolEmptyException 异常</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> PROXY_RAND_KEY_DEGRADED:<br>                <span class="hljs-keyword">raise</span><br>    <span class="hljs-comment"># 如果代理池为空，且设置了 PROXY_RAND_KEY_DEGRADED 为 True，则返回一个来自整个代理池的随机代理</span><br>    <span class="hljs-keyword">return</span> conn.random().string()<br><br><br><span class="hljs-comment"># 这是一个装饰器，将下面定义的 get_proxy_all 函数与路径 /all 绑定。因此，当用户访问 /all 路径时，将执行 get_proxy_all 函数</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/all&#x27;</span></span>)</span><br><span class="hljs-comment"># 这是一个装饰器，用于对 get_proxy_all 函数进行认证。它确保只有经过认证的用户才能访问 get_proxy_all 函数</span><br><span class="hljs-meta">@auth_required</span><br><span class="hljs-comment"># 路由处理函数。当用户访问 /all 路径时，该函数会被调用</span><br><span class="hljs-comment"># 作用是从代理池中获取所有的代理，并将它们以字符串的形式返回。可以通过查询参数 key 指定从哪个子池中获取代理</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy_all</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    get a random proxy</span><br><span class="hljs-string">    :return: get a random proxy</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 从 HTTP 请求的查询参数中获取名为 key 的值，这个值用于指定要查询的代理池的子池（如果有的话）</span><br>    key = request.args.get(<span class="hljs-string">&#x27;key&#x27;</span>)<br><br>    <span class="hljs-comment"># 调用 get_conn 函数获取 Redis 客户端连接对象</span><br>    conn = get_conn()<br>    <span class="hljs-comment"># 根据是否指定了 key 参数，决定从整个代理池中获取所有代理还是从指定的子池中获取所有代理</span><br>    proxies = conn.<span class="hljs-built_in">all</span>(key) <span class="hljs-keyword">if</span> key <span class="hljs-keyword">else</span> conn.<span class="hljs-built_in">all</span>()<br>    <span class="hljs-comment"># 初始化一个空字符串 proxies_string，用于存储代理列表的字符串表示形式</span><br>    proxies_string = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 用于检查获取到的代理列表是否为空。如果不为空，则执行下面的循环；否则，直接返回空字符串</span><br>    <span class="hljs-keyword">if</span> proxies:<br>        <span class="hljs-keyword">for</span> proxy <span class="hljs-keyword">in</span> proxies:<br>            <span class="hljs-comment"># 遍历获取到的代理列表，并将每个代理的字符串表示形式添加到 proxies_string 中</span><br>            proxies_string += <span class="hljs-built_in">str</span>(proxy) + <span class="hljs-string">&#x27;\n&#x27;</span><br>    <span class="hljs-comment"># 返回代理列表的字符串表示形式</span><br>    <span class="hljs-keyword">return</span> proxies_string<br><br><br><span class="hljs-comment"># 这是一个装饰器，将下面定义的 get_count 函数与路径 /count 绑定。因此，当用户访问 /count 路径时，将执行 get_count 函数</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/count&#x27;</span></span>)</span><br><span class="hljs-comment"># 这是一个装饰器，用于对 get_count 函数进行认证。它确保只有经过认证的用户才能访问 get_count 函数</span><br><span class="hljs-meta">@auth_required</span><br><span class="hljs-comment"># 路由处理函数。当用户访问 /count 路径时，该函数会被调用</span><br><span class="hljs-comment"># 作用是获取代理池中代理的数量，并以字符串的形式返回。可以通过查询参数 key 指定从哪个子池中获取代理数量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_count</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    get the count of proxies</span><br><span class="hljs-string">    :return: count, int</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 调用 get_conn 函数获取 Redis 客户端连接对象</span><br>    conn = get_conn()<br>    <span class="hljs-comment"># 从 HTTP 请求的查询参数中获取名为 key 的值，这个值用于指定要查询的代理池的子池（如果有的话）</span><br>    key = request.args.get(<span class="hljs-string">&#x27;key&#x27;</span>)<br>    <span class="hljs-comment"># 根据是否指定了 key 参数，决定获取整个代理池的代理数量还是指定子池的代理数量。然后将获取到的数量转换为字符串并返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(conn.count(key)) <span class="hljs-keyword">if</span> key <span class="hljs-keyword">else</span> conn.count()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 调用 Flask 应用程序对象 app 的 run() 方法来运行应用程序。host 参数指定了应用程序监听的主机地址，</span><br>    <span class="hljs-comment"># 通常设置为 API_HOST，可能是一个 IP 地址或者域名。port 参数指定了应用程序监听的端口号，通常设置为 API_PORT，</span><br>    <span class="hljs-comment"># threaded 参数指定了是否使用多线程处理请求，通常设置为 API_THREADED</span><br>    app.run(host=API_HOST, port=API_PORT, threaded=API_THREADED)<br></code></pre></td></tr></table></figure>

<p>这里我们声明了一个 Flask 对象，定义了 3 个接口，分别是首页、随机代理页和获取数量页。</p>
<p>运行之后，Flask 会启动一个 Web 服务，我们只需要访问对应的接口即可获取到可用代理。</p>
<p><strong>调度模块</strong></p>
<p>调度模块就是调用上面所定义的获取、检测、接口 3 个模块，将这 3 个模块通过多进程的形式运行起来，示例如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> multiprocessing<br><span class="hljs-keyword">from</span> proxypool.processors.server <span class="hljs-keyword">import</span> app<br><span class="hljs-keyword">from</span> proxypool.processors.getter <span class="hljs-keyword">import</span> Getter<br><span class="hljs-keyword">from</span> proxypool.processors.tester <span class="hljs-keyword">import</span> Tester<br><span class="hljs-keyword">from</span> proxypool.setting <span class="hljs-keyword">import</span> APP_PROD_METHOD_GEVENT, APP_PROD_METHOD_MEINHELD, APP_PROD_METHOD_TORNADO, CYCLE_GETTER, CYCLE_TESTER, API_HOST, \<br>    API_THREADED, API_PORT, ENABLE_SERVER, IS_PROD, APP_PROD_METHOD, \<br>    ENABLE_GETTER, ENABLE_TESTER, IS_WINDOWS<br><span class="hljs-keyword">from</span> loguru <span class="hljs-keyword">import</span> logger<br><br><br><span class="hljs-comment"># 在Windows系统下调用了multiprocessing.freeze_support()，用于“冻结”进程支持，这是为了确保Windows上的多进程子进程能够正确地执行</span><br><span class="hljs-keyword">if</span> IS_WINDOWS:<br>    multiprocessing.freeze_support()<br><br><span class="hljs-comment"># 初始化了三个进程对象tester_process、getter_process和server_process，它们分别用于执行测试器、获取器和服务器的功能</span><br>tester_process, getter_process, server_process = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 实现代理池的各个模块的调度和运行，它会根据配置启动测试器、获取器和API服务器，并在运行过程中持续监控各个进程的状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    scheduler</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_tester</span>(<span class="hljs-params">self, cycle=CYCLE_TESTER</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        run tester</span><br><span class="hljs-string">        运行测试器。如果测试器未启用，将记录一条信息并退出。否则，会创建一个 Tester 的实例，</span><br><span class="hljs-string">        并在一个无限循环中运行 Tester 的 run 方法，然后根据指定的周期 cycle （默认为 CYCLE_TESTER）暂停一段时间</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 检查变量 ENABLE_TESTER，如果其值为 False，表示测试器未启用</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ENABLE_TESTER:<br>            <span class="hljs-comment"># 记录一条日志信息，说明测试器未启用，并提示即将退出</span><br>            logger.info(<span class="hljs-string">&#x27;tester not enabled, exit&#x27;</span>)<br>            <span class="hljs-comment"># 退出方法，因为测试器未启用，无需继续执行</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 创建一个名为 tester 的 Tester 类的实例，用于执行测试操作</span><br>        tester = Tester()<br>        <span class="hljs-comment"># 初始化一个循环计数器 loop，用于跟踪测试器的循环次数</span><br>        loop = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 无限循环</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 记录一条调试级别的日志信息，显示测试器的循环次数</span><br>            logger.debug(<span class="hljs-string">f&#x27;tester loop <span class="hljs-subst">&#123;loop&#125;</span> start...&#x27;</span>)<br>            <span class="hljs-comment"># 调用 tester 实例的 run 方法，执行测试操作</span><br>            tester.run()<br>            <span class="hljs-comment"># 增加循环计数器 loop 的值，以便跟踪循环次数</span><br>            loop += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 暂停程序的执行，等待一段时间。cycle 参数指定了暂停的时间，即测试器运行的周期。</span><br>            <span class="hljs-comment"># 这样，每次循环中，测试器都会被执行一次，然后暂停一段时间，以达到周期性地执行测试的目的</span><br>            time.sleep(cycle)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_getter</span>(<span class="hljs-params">self, cycle=CYCLE_GETTER</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        run getter</span><br><span class="hljs-string">        运行获取器。如果获取器未启用，将记录一条信息并退出。否则，会创建一个 Getter 的实例，</span><br><span class="hljs-string">        并在一个无限循环中运行 Getter 的 run 方法，然后根据指定的周期 cycle （默认为 CYCLE_GETTER）暂停一段时间</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 检查变量 ENABLE_GETTER，如果其值为 False，表示获取器未启用</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ENABLE_GETTER:<br>            <span class="hljs-comment"># 记录一条信息级别的日志，说明获取器未启用，并提示即将退出</span><br>            logger.info(<span class="hljs-string">&#x27;getter not enabled, exit&#x27;</span>)<br>            <span class="hljs-comment"># 退出方法，因为获取器未启用，无需继续执行</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 创建一个名为 getter 的 Getter 类的实例，用于执行获取操作</span><br>        getter = Getter()<br>        <span class="hljs-comment"># 初始化一个循环计数器 loop，用于跟踪获取器的循环次数</span><br>        loop = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 无限循环</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 记录一条调试级别的日志，显示获取器的循环次数</span><br>            logger.debug(<span class="hljs-string">f&#x27;getter loop <span class="hljs-subst">&#123;loop&#125;</span> start...&#x27;</span>)<br>            <span class="hljs-comment"># 调用 getter 实例的 run 方法，执行获取操作</span><br>            getter.run()<br>            <span class="hljs-comment"># 增加循环计数器 loop 的值，以便跟踪循环次数</span><br>            loop += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 暂停程序的执行，等待一段时间。cycle 参数指定了暂停的时间，即获取器运行的周期。</span><br>            <span class="hljs-comment"># 这样，每次循环中，获取器都会被执行一次，然后暂停一段时间，以达到周期性地执行获取操作的目的</span><br>            time.sleep(cycle)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_server</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        run server for api</span><br><span class="hljs-string">        运行API服务器。如果服务器未启用，将记录一条信息并退出。根据 IS_PROD 和 APP_PROD_METHOD 的设置，</span><br><span class="hljs-string">        选择使用不同的服务器方法（gevent、tornado、meinheld或者默认的flask），然后启动相应的服务器</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 检查变量 ENABLE_SERVER，如果其值为 False，表示服务器未启用</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ENABLE_SERVER:<br>            <span class="hljs-comment"># 记录一条信息级别的日志，说明服务器未启用，并提示即将退出</span><br>            logger.info(<span class="hljs-string">&#x27;server not enabled, exit&#x27;</span>)<br>            <span class="hljs-comment"># 退出方法，因为服务器未启用，无需继续执行</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 检查变量 IS_PROD，如果其值为 True，表示当前环境为生产环境</span><br>        <span class="hljs-keyword">if</span> IS_PROD:<br>            <span class="hljs-comment"># 检查生产环境下选择的服务器方法是否为 gevent</span><br>            <span class="hljs-keyword">if</span> APP_PROD_METHOD == APP_PROD_METHOD_GEVENT:<br>                <span class="hljs-comment"># 尝试导入 gevent.pywsgi 模块，用于创建 WSGIServer 实例</span><br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">from</span> gevent.pywsgi <span class="hljs-keyword">import</span> WSGIServer<br>                <span class="hljs-comment"># 捕获 ImportError 异常，如果导入失败，则记录异常信息</span><br>                <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:<br>                    logger.exception(e)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 创建一个 WSGIServer 实例，指定 API 的主机和端口，并将 app 作为处理请求的应用程序</span><br>                    http_server = WSGIServer((API_HOST, API_PORT), app)<br>                    <span class="hljs-comment"># 启动 WSGIServer，开始监听请求并永久运行</span><br>                    http_server.serve_forever()<br><br>            <span class="hljs-comment"># 如果生产环境下选择的服务器方法为 tornado，执行以下代码块</span><br>            <span class="hljs-keyword">elif</span> APP_PROD_METHOD == APP_PROD_METHOD_TORNADO:<br>                <span class="hljs-comment"># 尝试导入 tornado.wsgi、tornado.httpserver 和 tornado.ioloop 模块</span><br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">from</span> tornado.wsgi <span class="hljs-keyword">import</span> WSGIContainer<br>                    <span class="hljs-keyword">from</span> tornado.httpserver <span class="hljs-keyword">import</span> HTTPServer<br>                    <span class="hljs-keyword">from</span> tornado.ioloop <span class="hljs-keyword">import</span> IOLoop<br>                <span class="hljs-comment"># 捕获 ImportError 异常，如果导入失败，则记录异常信息</span><br>                <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:<br>                    logger.exception(e)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 创建一个 HTTPServer 实例，将 app 包装在 WSGIContainer 中，用于处理请求</span><br>                    http_server = HTTPServer(WSGIContainer(app))<br>                    <span class="hljs-comment"># 监听指定端口，准备接收请求</span><br>                    http_server.listen(API_PORT)<br>                    <span class="hljs-comment"># 启动 IOLoop，开始监听请求并永久运行</span><br>                    IOLoop.instance().start()<br><br>            <span class="hljs-comment"># 如果生产环境下选择的服务器方法为 meinheld，执行以下代码块</span><br>            <span class="hljs-keyword">elif</span> APP_PROD_METHOD == APP_PROD_METHOD_MEINHELD:<br>                <span class="hljs-comment"># 尝试导入 meinheld 模块</span><br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">import</span> meinheld<br>                <span class="hljs-comment"># 捕获 ImportError 异常，如果导入失败，则记录异常信息</span><br>                <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:<br>                    logger.exception(e)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 将 meinheld 绑定到指定的主机和端口</span><br>                    meinheld.listen((API_HOST, API_PORT))<br>                    <span class="hljs-comment"># 启动 meinheld 服务器，开始监听请求并永久运行</span><br>                    meinheld.run(app)<br><br>            <span class="hljs-comment"># 如果生产环境下选择的服务器方法不在支持的列表中，执行以下代码块</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 记录一条错误级别的日志，指示选择的服务器方法不受支持</span><br>                logger.error(<span class="hljs-string">&quot;unsupported APP_PROD_METHOD&quot;</span>)<br>                <span class="hljs-comment"># 退出方法</span><br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 如果不是生产环境，则执行以下代码块</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用 Flask 的内置服务器运行应用程序，指定主机、端口和其他选项</span><br>            app.run(host=API_HOST, port=API_PORT, threaded=API_THREADED, use_reloader=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Run the scheduler</span><br><span class="hljs-string">        运行整个代理池。在这个方法中，会根据各个模块的启用状态创建相应的进程，并启动它们。</span><br><span class="hljs-string">        然后使用 join 方法等待这些进程执行完毕。同时捕获 KeyboardInterrupt 异常，在收到中断信号时终止各个进程，并记录相应的信息。</span><br><span class="hljs-string">        最后，再次使用 join 方法等待进程的结束，并记录每个进程是否仍然存活</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 声明 tester_process、getter_process 和 server_process 为全局变量</span><br>        <span class="hljs-keyword">global</span> tester_process, getter_process, server_process<br>        <span class="hljs-comment"># 尝试执行以下代码块</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 记录一条信息级别的日志，表示开始启动代理池</span><br>            logger.info(<span class="hljs-string">&#x27;starting proxypool...&#x27;</span>)<br>            <span class="hljs-comment"># 检查是否启用了测试器</span><br>            <span class="hljs-keyword">if</span> ENABLE_TESTER:<br>                <span class="hljs-comment"># 创建一个名为 tester_process 的多进程，目标函数为 self.run_tester，即运行测试器的方法</span><br>                tester_process = multiprocessing.Process(<br>                    target=<span class="hljs-variable language_">self</span>.run_tester)<br>                <span class="hljs-comment"># 记录一条信息级别的日志，显示正在启动测试器的进程ID</span><br>                logger.info(<span class="hljs-string">f&#x27;starting tester, pid <span class="hljs-subst">&#123;tester_process.pid&#125;</span>...&#x27;</span>)<br>                <span class="hljs-comment"># 启动测试器的进程</span><br>                tester_process.start()<br><br>            <span class="hljs-comment"># 检查是否启用了获取器</span><br>            <span class="hljs-keyword">if</span> ENABLE_GETTER:<br>                <span class="hljs-comment"># 创建一个名为 getter_process 的多进程，目标函数为 self.run_getter，即运行获取器的方法</span><br>                getter_process = multiprocessing.Process(<br>                    target=<span class="hljs-variable language_">self</span>.run_getter)<br>                <span class="hljs-comment"># 记录一条信息级别的日志，显示正在启动获取器的进程ID</span><br>                logger.info(<span class="hljs-string">f&#x27;starting getter, pid <span class="hljs-subst">&#123;getter_process.pid&#125;</span>...&#x27;</span>)<br>                <span class="hljs-comment"># 启动获取器的进程</span><br>                getter_process.start()<br><br>            <span class="hljs-comment"># 检查是否启用了API服务器</span><br>            <span class="hljs-keyword">if</span> ENABLE_SERVER:<br>                <span class="hljs-comment"># 创建一个名为 server_process 的多进程，目标函数为 self.run_server，即运行API服务器的方法</span><br>                server_process = multiprocessing.Process(<br>                    target=<span class="hljs-variable language_">self</span>.run_server)<br>                <span class="hljs-comment"># 记录一条信息级别的日志，显示正在启动API服务器的进程ID</span><br>                logger.info(<span class="hljs-string">f&#x27;starting server, pid <span class="hljs-subst">&#123;server_process.pid&#125;</span>...&#x27;</span>)<br>                <span class="hljs-comment"># 启动API服务器的进程</span><br>                server_process.start()<br><br>            <span class="hljs-comment"># 使用短路逻辑，如果 tester_process 存在且不为 None，则调用其 join 方法，等待测试器进程执行完毕</span><br>            tester_process <span class="hljs-keyword">and</span> tester_process.join()<br>            <span class="hljs-comment"># 同上，等待获取器进程执行完毕</span><br>            getter_process <span class="hljs-keyword">and</span> getter_process.join()<br>            <span class="hljs-comment"># 同上，等待API服务器进程执行完毕</span><br>            server_process <span class="hljs-keyword">and</span> server_process.join()<br>        <span class="hljs-comment"># 如果捕获到 KeyboardInterrupt 异常（用户按下了键盘中断信号）</span><br>        <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>            <span class="hljs-comment"># 记录一条信息级别的日志，表示收到了键盘中断信号</span><br>            logger.info(<span class="hljs-string">&#x27;received keyboard interrupt signal&#x27;</span>)<br>            <span class="hljs-comment"># 使用短路逻辑，如果 tester_process 存在且不为 None，则终止测试器进程</span><br>            tester_process <span class="hljs-keyword">and</span> tester_process.terminate()<br>            <span class="hljs-comment"># 同上，终止获取器进程</span><br>            getter_process <span class="hljs-keyword">and</span> getter_process.terminate()<br>            <span class="hljs-comment"># 同上，终止API服务器进程</span><br>            server_process <span class="hljs-keyword">and</span> server_process.terminate()<br>        <span class="hljs-comment"># 不管是否发生异常，都会执行以下代码块</span><br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># must call join method before calling is_alive</span><br>            <span class="hljs-comment"># 使用短路逻辑，如果 tester_process 存在且不为 None，则调用其 join 方法，确保测试器进程已结束</span><br>            tester_process <span class="hljs-keyword">and</span> tester_process.join()<br>            <span class="hljs-comment"># 同上，确保获取器进程已结束</span><br>            getter_process <span class="hljs-keyword">and</span> getter_process.join()<br>            <span class="hljs-comment"># 同上，确保API服务器进程已结束</span><br>            server_process <span class="hljs-keyword">and</span> server_process.join()<br>            <span class="hljs-comment"># 记录一条信息级别的日志，显示测试器进程是否仍然存活</span><br>            logger.info(<br>                <span class="hljs-string">f&#x27;tester is <span class="hljs-subst">&#123;<span class="hljs-string">&quot;alive&quot;</span> <span class="hljs-keyword">if</span> tester_process.is_alive() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;dead&quot;</span>&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># 同上，显示获取器进程是否仍然存活</span><br>            logger.info(<br>                <span class="hljs-string">f&#x27;getter is <span class="hljs-subst">&#123;<span class="hljs-string">&quot;alive&quot;</span> <span class="hljs-keyword">if</span> getter_process.is_alive() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;dead&quot;</span>&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># 同上，显示API服务器进程是否仍然存活</span><br>            logger.info(<br>                <span class="hljs-string">f&#x27;server is <span class="hljs-subst">&#123;<span class="hljs-string">&quot;alive&quot;</span> <span class="hljs-keyword">if</span> server_process.is_alive() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;dead&quot;</span>&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># 记录一条信息级别的日志，表示代理终止</span><br>            logger.info(<span class="hljs-string">&#x27;proxy terminated&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    scheduler = Scheduler()<br>    scheduler.run()<br></code></pre></td></tr></table></figure>

<p>3 个常量 <code>ENABLE_TESTER</code>、<code>ENABLE_GETTER</code> 和 <code>ENABLE_SERVER</code> 都是布尔类型，表示测试模块、获取模块和接口模块的开关，如果都为 <code>True</code>，则代表模块开启。</p>
<p>启动入口是 <code>run</code> 方法，这个方法分别判断 3 个模块的开关。如果开关开启，启动时程序就新建一个 Process 进程，设置好启动目标，然后调用 <code>start</code> 方法运行，这样 3 个进程就可以并行执行，互不干扰。</p>
<p>3 个调度方法的结构也非常清晰。比如，<code>run_tester</code> 方法用来调度测试模块。首先声明一个 Tester 对象，然后进入死循环不断循环调用其 <code>run</code> 方法，执行完一轮之后就休眠一段时间，休眠结束之后重新再执行。这里休眠时间也定义为一个常量，如 20 秒，即每隔 20 秒进行一次代理检测。</p>
<p>最后，只需要调用 <code>Scheduler</code> 的 <code>run</code> 方法即可启动整个代理池。</p>
<p>以上内容便是整个代理池的架构和相应实现逻辑。</p>
</li>
<li><p>运行</p>
<p>接下来，我们将代码整合一下，将代理运行起来，运行之后的输出结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2025</span>-03-03 02:<span class="hljs-number">52</span>:<span class="hljs-number">06.510</span> | INFO     | proxypool.storages.redis:decrease:<span class="hljs-number">73</span> - <span class="hljs-number">60.186</span><span class="hljs-number">.146</span><span class="hljs-number">.193</span>:<span class="hljs-number">9000</span> current score <span class="hljs-number">10.0</span>, decrease <span class="hljs-number">1</span><br><span class="hljs-number">2025</span>-03-03 02:<span class="hljs-number">52</span>:<span class="hljs-number">06.532</span> | DEBUG    | proxypool.processors.tester:test:<span class="hljs-number">52</span> - proxy <span class="hljs-number">60.186</span><span class="hljs-number">.151</span><span class="hljs-number">.147</span>:<span class="hljs-number">9000</span> <span class="hljs-keyword">is</span> invalid, decrease score<br><span class="hljs-number">2025</span>-03-03 02:<span class="hljs-number">52</span>:<span class="hljs-number">07.159</span> | INFO     | proxypool.storages.redis:<span class="hljs-built_in">max</span>:<span class="hljs-number">96</span> - <span class="hljs-number">60.191</span><span class="hljs-number">.11</span><span class="hljs-number">.246</span>:<span class="hljs-number">3128</span> <span class="hljs-keyword">is</span> valid, <span class="hljs-built_in">set</span> to <span class="hljs-number">100</span><br><span class="hljs-number">2025</span>-03-03 02:<span class="hljs-number">52</span>:<span class="hljs-number">07.167</span> | DEBUG    | proxypool.processors.tester:test:<span class="hljs-number">46</span> - proxy <span class="hljs-number">60.191</span><span class="hljs-number">.11</span><span class="hljs-number">.246</span>:<span class="hljs-number">3128</span> <span class="hljs-keyword">is</span> valid, <span class="hljs-built_in">set</span> <span class="hljs-built_in">max</span> score<br></code></pre></td></tr></table></figure>

<p>以上是代理池的控制台输出，可以看到这里将可用代理设置为 100，不可用代理分数减 1 。</p>
<p>接下来，我们再打开浏览器，当前配置运行在 5555 端口，所以打开 <a target="_blank" rel="noopener" href="http://127.0.0.1:5555/">http://127.0.0.1:5555</a> 即可看到其首页，如图所示。</p>
<p><img src="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304155642843.png" srcset="/img/loading.gif" lazyload><br>再访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:5555/random%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%90%86%EF%BC%8C%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">http://127.0.0.1:5555/random，即可获取随机可用代理，如图所示：</a></p>
<p><img src="https://nail-clipper.oss-cn-beijing.aliyuncs.com/img/image-20250304155944933.png" srcset="/img/loading.gif" lazyload alt="image-20250304155944933"></p>
<p>只需要访问此接口，即可获取一个随机可用代理，这非常方便。</p>
<p>获取代理的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>PROXY_POOL_URL = <span class="hljs-string">&#x27;http://localhost:5555/random&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_proxy</span>():<br>    <span class="hljs-keyword">try</span>:<br>        response = requests.get(PROXY_POOL_URL)<br>        <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">except</span> ConnectionError:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<p>这样便可以获取到一个随机代理了。有了代理池之后，再取出代理即可有效防止 IP 被封禁的情况。</p>
</li>
</ol>
<h2 id="07-运行代理池"><a href="#07-运行代理池" class="headerlink" title="07. 运行代理池"></a>07. 运行代理池</h2><ol>
<li><p>安装和配置Redis</p>
<p>本地安装 Redis、Docker 启动 Redis、远程 Redis 都是可以的，只要能正常连接使用即可。</p>
<p>首先可以需要一下环境变量，代理池会通过环境变量读取这些值。</p>
<p>设置 Redis 的环境变量有两种方式，一种是分别设置 host、port、password，另一种是设置连接字符串，设置方法分别如下：</p>
<p>设置 host、port、password，如果 password 为空可以设置为空字符串，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PROXYPOOL_REDIS_HOST=<span class="hljs-string">&#x27;localhost&#x27;</span><br><span class="hljs-built_in">export</span> PROXYPOOL_REDIS_PORT=6379<br><span class="hljs-built_in">export</span> PROXYPOOL_REDIS_PASSWORD=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> PROXYPOOL_REDIS_DB=0<br></code></pre></td></tr></table></figure>

<p>或者只设置连接字符串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PROXYPOOL_REDIS_CONNECTION_STRING=<span class="hljs-string">&#x27;redis://localhost&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这里连接字符串的格式需要符合 <code>redis://[:password@]host[:port][/database]</code> 的格式， 中括号参数可以省略，port 默认是 6379，database 默认是 0，密码默认为空。</p>
<p>以上两种设置任选其一即可。</p>
</li>
<li><p>安装依赖包</p>
<p>这里强烈推荐使用 <a target="_blank" rel="noopener" href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-with-commands">Conda</a> 或 <a target="_blank" rel="noopener" href="https://virtualenv.pypa.io/en/latest/user_guide.html">virtualenv</a> 创建虚拟环境，Python 版本不低于 3.6。</p>
<p>然后 pip 安装依赖即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure>
</li>
<li><p>运行代理池</p>
<p>两种方式运行代理池，一种是 Tester、Getter、Server 全部运行，另一种是按需分别运行。</p>
<p>一般来说可以选择全部运行，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 run.py<br></code></pre></td></tr></table></figure>

<p>关于 run.py 的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> proxypool.scheduler <span class="hljs-keyword">import</span> Scheduler<br><span class="hljs-keyword">import</span> argparse<br><br><br><span class="hljs-comment"># 创建了一个 ArgumentParser 对象 parser，用于解析命令行参数。设置了一个描述信息，描述了这个命令行工具的作用为 ProxyPool</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;ProxyPool&#x27;</span>)<br><span class="hljs-comment"># 向 ArgumentParser 对象中添加了一个命令行参数 --processor，指定了参数类型为字符串，并提供了帮助信息</span><br>parser.add_argument(<span class="hljs-string">&#x27;--processor&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;processor to run&#x27;</span>)<br><span class="hljs-comment"># 调用 parse_args() 方法解析命令行参数，并将解析结果存储在 args 变量中</span><br>args = parser.parse_args()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># if processor set, just run it</span><br>    <span class="hljs-comment"># 检查命令行参数中是否指定了 --processor，如果指定了，即说明用户希望运行特定的处理器模块</span><br>    <span class="hljs-keyword">if</span> args.processor:<br>        <span class="hljs-comment"># 如果指定了 --processor，则动态调用 Scheduler 类中对应的处理器方法，方法名称由命令行参数指定。</span><br>        <span class="hljs-comment"># getattr() 函数用于获取对象的属性或方法，第一个参数为对象，第二个参数为属性或方法名字符串。</span><br>        <span class="hljs-comment"># f&#x27;run_&#123;args.processor&#125;&#x27; 构建了方法名字符串，例如如果 args.processor 的值为 &#x27;tester&#x27;，则动态调用 Scheduler 类的 run_tester() 方法</span><br>        <span class="hljs-built_in">getattr</span>(Scheduler(), <span class="hljs-string">f&#x27;run_<span class="hljs-subst">&#123;args.processor&#125;</span>&#x27;</span>)()<br>    <span class="hljs-comment"># 如果未指定 --processor，即用户没有传递任何参数，则执行以下代码块</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 创建一个 Scheduler 的实例，并调用其 run 方法，启动整个代理池程序的运行</span><br>        Scheduler().run()<br></code></pre></td></tr></table></figure>

<p>运行之后会启动 Tester、Getter、Server，这时访问 <a target="_blank" rel="noopener" href="http://localhost:5555/random">http://localhost:5555/random</a> 即可获取一个随机可用代理。</p>
<p>或者如果你弄清楚了代理池的架构，可以按需分别运行，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 run.py --processor getter<br>python3 run.py --processor tester<br>python3 run.py --processor server<br></code></pre></td></tr></table></figure>

<p>这里 processor 可以指定运行 Tester、Getter 还是 Server。</p>
</li>
<li><p>使用示例</p>
<p>成功运行之后可以通过 <a target="_blank" rel="noopener" href="http://localhost:5555/random">http://localhost:5555/random</a> 获取一个随机可用代理。</p>
<p>可以用程序对接实现，下面的示例展示了获取代理并爬取网页的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>proxypool_url = <span class="hljs-string">&#x27;http://127.0.0.1:5555/random&#x27;</span><br>target_url = <span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_random_proxy</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    get random proxy from proxypool</span><br><span class="hljs-string">    :return: proxy</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> requests.get(proxypool_url).text.strip()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl</span>(<span class="hljs-params">url, proxy</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    use proxy to crawl page</span><br><span class="hljs-string">    :param url: page url</span><br><span class="hljs-string">    :param proxy: proxy, such as 8.8.8.8:8888</span><br><span class="hljs-string">    :return: html</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    proxies = &#123;<span class="hljs-string">&#x27;http&#x27;</span>: <span class="hljs-string">&#x27;http://&#x27;</span> + proxy&#125;<br>    <span class="hljs-keyword">return</span> requests.get(url, proxies=proxies).text<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    main method, entry point</span><br><span class="hljs-string">    :return: none</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    proxy = get_random_proxy()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get random proxy&#x27;</span>, proxy)<br>    html = crawl(target_url, proxy)<br>    <span class="hljs-built_in">print</span>(html)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">get random proxy <span class="hljs-number">116.196</span><span class="hljs-number">.115</span><span class="hljs-number">.209</span>:<span class="hljs-number">8080</span><br>&#123;<br>  <span class="hljs-string">&quot;args&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;headers&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;*/*&quot;</span>,<br>    <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate&quot;</span>,<br>    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;httpbin.org&quot;</span>,<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;python-requests/2.22.0&quot;</span>,<br>    <span class="hljs-string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="hljs-string">&quot;Root=1-5e4d7140-662d9053c0a2e513c7278364&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;origin&quot;</span>: <span class="hljs-string">&quot;116.196.115.209&quot;</span>,<br>  <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://httpbin.org/get&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到成功获取了代理，并请求 httpbin.org 验证了代理的可用性。</p>
</li>
<li><p>可配置项</p>
<p>代理池可以通过设置环境变量来配置一些参数。</p>
<p><strong>开关</strong></p>
<ul>
<li>ENABLE_TESTER：允许 Tester 启动，默认 true</li>
<li>ENABLE_GETTER：允许 Getter 启动，默认 true</li>
<li>ENABLE_SERVER：运行 Server 启动，默认 true</li>
</ul>
<p><strong>环境</strong></p>
<ul>
<li>APP_ENV：运行环境，可以设置 dev、test、prod，即开发、测试、生产环境，默认 dev</li>
<li>APP_DEBUG：调试模式，可以设置 true 或 false，默认 true</li>
<li>APP_PROD_METHOD: 正式环境启动应用方式，默认是<code>gevent</code>， 可选：<code>tornado</code>，<code>meinheld</code>（分别需要安装 tornado 或 meinheld 模块）</li>
</ul>
<p><strong>Redis 连接</strong></p>
<ul>
<li>PROXYPOOL_REDIS_HOST &#x2F; REDIS_HOST：Redis 的 Host，其中 PROXYPOOL_REDIS_HOST 会覆盖 REDIS_HOST 的值。</li>
<li>PROXYPOOL_REDIS_PORT &#x2F; REDIS_PORT：Redis 的端口，其中 PROXYPOOL_REDIS_PORT 会覆盖 REDIS_PORT 的值。</li>
<li>PROXYPOOL_REDIS_PASSWORD &#x2F; REDIS_PASSWORD：Redis 的密码，其中 PROXYPOOL_REDIS_PASSWORD 会覆盖 REDIS_PASSWORD 的值。</li>
<li>PROXYPOOL_REDIS_DB &#x2F; REDIS_DB：Redis 的数据库索引，如 0、1，其中 PROXYPOOL_REDIS_DB 会覆盖 REDIS_DB 的值。</li>
<li>PROXYPOOL_REDIS_CONNECTION_STRING &#x2F; REDIS_CONNECTION_STRING：Redis 连接字符串，其中 PROXYPOOL_REDIS_CONNECTION_STRING 会覆盖 REDIS_CONNECTION_STRING 的值。</li>
<li>PROXYPOOL_REDIS_KEY &#x2F; REDIS_KEY：Redis 储存代理使用字典的名称，其中 PROXYPOOL_REDIS_KEY 会覆盖 REDIS_KEY 的值。</li>
</ul>
<p><strong>处理器</strong></p>
<ul>
<li>CYCLE_TESTER：Tester 运行周期，即间隔多久运行一次测试，默认 20 秒</li>
<li>CYCLE_GETTER：Getter 运行周期，即间隔多久运行一次代理获取，默认 100 秒</li>
<li>TEST_URL：测试 URL，默认百度</li>
<li>TEST_TIMEOUT：测试超时时间，默认 10 秒</li>
<li>TEST_BATCH：批量测试数量，默认 20 个代理</li>
<li>TEST_VALID_STATUS：测试有效的状态码</li>
<li>API_HOST：代理 Server 运行 Host，默认 0.0.0.0</li>
<li>API_PORT：代理 Server 运行端口，默认 5555</li>
<li>API_THREADED：代理 Server 是否使用多线程，默认 true</li>
</ul>
<p><strong>日志</strong></p>
<ul>
<li>LOG_DIR：日志相对路径</li>
<li>LOG_RUNTIME_FILE：运行日志文件名称</li>
<li>LOG_ERROR_FILE：错误日志文件名称</li>
<li>LOG_ROTATION: 日志记录周转周期或大小，默认 500MB，见 <a target="_blank" rel="noopener" href="https://github.com/Delgan/loguru#easier-file-logging-with-rotation--retention--compression">loguru - rotation</a></li>
<li>LOG_RETENTION: 日志保留日期，默认 7 天，见 <a target="_blank" rel="noopener" href="https://github.com/Delgan/loguru#easier-file-logging-with-rotation--retention--compression">loguru - retention</a></li>
<li>ENABLE_LOG_FILE：是否输出 log 文件，默认 true，如果设置为 false，那么 ENABLE_LOG_RUNTIME_FILE 和 ENABLE_LOG_ERROR_FILE 都不会生效</li>
<li>ENABLE_LOG_RUNTIME_FILE：是否输出 runtime log 文件，默认 true</li>
<li>ENABLE_LOG_ERROR_FILE：是否输出 error log 文件，默认 true</li>
</ul>
<p>以上内容均可使用环境变量配置，即在运行前设置对应环境变量值即可，如更改测试地址和 Redis 键名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">export TEST_URL=http://weibo.cn<br>export REDIS_KEY=proxies:weibo<br></code></pre></td></tr></table></figure>

<p>即可构建一个专属于微博的代理池，有效的代理都是可以爬取微博的。</p>
<p><strong>扩展代理爬虫</strong></p>
<p>代理的爬虫均放置在 proxypool&#x2F;crawlers 文件夹下，目前对接了有限几个代理的爬虫。</p>
<p>若扩展一个爬虫，只需要在 crawlers 文件夹下新建一个 Python 文件声明一个 Class 即可。</p>
<p>写法规范如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyquery <span class="hljs-keyword">import</span> PyQuery <span class="hljs-keyword">as</span> pq<br><span class="hljs-keyword">from</span> proxypool.schemas.proxy <span class="hljs-keyword">import</span> Proxy<br><span class="hljs-keyword">from</span> proxypool.crawlers.base <span class="hljs-keyword">import</span> BaseCrawler<br><br>BASE_URL = <span class="hljs-string">&#x27;http://www.664ip.cn/&#123;page&#125;.html&#x27;</span><br>MAX_PAGE = <span class="hljs-number">5</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Daili66Crawler</span>(<span class="hljs-title class_ inherited__">BaseCrawler</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    daili66 crawler, http://www.66ip.cn/1.html</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    urls = [BASE_URL.<span class="hljs-built_in">format</span>(page=page) <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, MAX_PAGE + <span class="hljs-number">1</span>)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, html</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        parse html file to get proxies</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        doc = pq(html)<br>        trs = doc(<span class="hljs-string">&#x27;.containerbox table tr:gt(0)&#x27;</span>).items()<br>        <span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> trs:<br>            host = tr.find(<span class="hljs-string">&#x27;td:nth-child(1)&#x27;</span>).text()<br>            port = <span class="hljs-built_in">int</span>(tr.find(<span class="hljs-string">&#x27;td:nth-child(2)&#x27;</span>).text())<br>         <span class="hljs-keyword">yield</span> Proxy(host=host, port=port)<br></code></pre></td></tr></table></figure>
<p>在这里只需要定义一个 Crawler 继承 BaseCrawler 即可，然后定义好 urls 变量和 parse 方法即可。</p>
<ul>
<li>urls 变量即为爬取的代理网站网址列表，可以用程序定义也可写成固定内容。</li>
<li>parse 方法接收一个参数即 html，代理网址的 html，在 parse 方法里只需要写好 html 的解析，解析出 host 和 port，并构建 Proxy 对象 yield 返回即可。</li>
</ul>
<p>网页的爬取不需要实现，BaseCrawler 已经有了默认实现，如需更改爬取方式，重写 crawl 方法即可。</p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Arch/" class="category-chain-item">Arch</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Arch/" class="print-no-link">#Arch</a>
      
        <a href="/tags/Linux/" class="print-no-link">#Linux</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Arch Linux 魔法学院</div>
      <div>https://wxwdaydayup.top/Arch Linux 魔法学院/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Nail Clipper</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
